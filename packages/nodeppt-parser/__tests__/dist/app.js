!function(n){var e=this.webpackHotUpdate;this.webpackHotUpdate=function(n,t){!function(n,e){if(!h[n]||!m[n])return;for(var t in m[n]=!1,e)Object.prototype.hasOwnProperty.call(e,t)&&(C[t]=e[t]);0==--A&&0===Z&&p()}(n,t),e&&e(n,t)};var t,l=!0,g="d222a02b50193fa0b925",I=1e4,i={},c=[],d=[];function s(n){var e=r[n];if(!e)return U;var l=function(l){return e.hot.active?(r[l]?-1===r[l].parents.indexOf(n)&&r[l].parents.push(n):(c=[n],t=l),-1===e.children.indexOf(l)&&e.children.push(l)):(console.warn("[HMR] unexpected require("+l+") from disposed module "+n),c=[]),U(l)},g=function(n){return{configurable:!0,enumerable:!0,get:function(){return U[n]},set:function(e){U[n]=e}}};for(var I in U)Object.prototype.hasOwnProperty.call(U,I)&&"e"!==I&&"t"!==I&&Object.defineProperty(l,I,g(I));return l.e=function(n){return"ready"===B&&G("prepare"),Z++,U.e(n).then(e,function(n){throw e(),n});function e(){Z--,"prepare"===B&&(Q[n]||X(n),0===Z&&0===A&&p())}},l.t=function(n,e){return 1&e&&(n=l(n)),U.t(n,-2&e)},l}function b(n){var e={_acceptedDependencies:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_disposeHandlers:[],_main:t!==n,active:!0,accept:function(n,t){if(void 0===n)e._selfAccepted=!0;else if("function"==typeof n)e._selfAccepted=n;else if("object"==typeof n)for(var l=0;l<n.length;l++)e._acceptedDependencies[n[l]]=t||function(){};else e._acceptedDependencies[n]=t||function(){}},decline:function(n){if(void 0===n)e._selfDeclined=!0;else if("object"==typeof n)for(var t=0;t<n.length;t++)e._declinedDependencies[n[t]]=!0;else e._declinedDependencies[n]=!0},dispose:function(n){e._disposeHandlers.push(n)},addDisposeHandler:function(n){e._disposeHandlers.push(n)},removeDisposeHandler:function(n){var t=e._disposeHandlers.indexOf(n);t>=0&&e._disposeHandlers.splice(t,1)},check:V,apply:W,status:function(n){if(!n)return B;a.push(n)},addStatusHandler:function(n){a.push(n)},removeStatusHandler:function(n){var e=a.indexOf(n);e>=0&&a.splice(e,1)},data:i[n]};return t=void 0,e}var a=[],B="idle";function G(n){B=n;for(var e=0;e<a.length;e++)a[e].call(null,n)}var o,C,u,A=0,Z=0,Q={},m={},h={};function F(n){return+n+""===n?+n:n}function V(n){if("idle"!==B)throw new Error("check() is only allowed in idle status");return l=n,G("check"),(e=I,e=e||1e4,new Promise(function(n,t){if("undefined"==typeof XMLHttpRequest)return t(new Error("No browser support"));try{var l=new XMLHttpRequest,I=U.p+""+g+".hot-update.json";l.open("GET",I,!0),l.timeout=e,l.send(null)}catch(n){return t(n)}l.onreadystatechange=function(){if(4===l.readyState)if(0===l.status)t(new Error("Manifest request to "+I+" timed out."));else if(404===l.status)n();else if(200!==l.status&&304!==l.status)t(new Error("Manifest request to "+I+" failed."));else{try{var e=JSON.parse(l.responseText)}catch(n){return void t(n)}n(e)}}})).then(function(n){if(!n)return G("idle"),null;m={},Q={},h=n.c,u=n.h,G("prepare");var e=new Promise(function(n,e){o={resolve:n,reject:e}});C={};return X(0),"prepare"===B&&0===Z&&0===A&&p(),e});var e}function X(n){h[n]?(m[n]=!0,A++,function(n){var e=document.createElement("script");e.charset="utf-8",e.src=U.p+""+n+"."+g+".hot-update.js",document.head.appendChild(e)}(n)):Q[n]=!0}function p(){G("ready");var n=o;if(o=null,n)if(l)Promise.resolve().then(function(){return W(l)}).then(function(e){n.resolve(e)},function(e){n.reject(e)});else{var e=[];for(var t in C)Object.prototype.hasOwnProperty.call(C,t)&&e.push(F(t));n.resolve(e)}}function W(e){if("ready"!==B)throw new Error("apply() is only allowed in ready status");var t,l,I,d,s;function b(n){for(var e=[n],t={},l=e.slice().map(function(n){return{chain:[n],id:n}});l.length>0;){var g=l.pop(),I=g.id,i=g.chain;if((d=r[I])&&!d.hot._selfAccepted){if(d.hot._selfDeclined)return{type:"self-declined",chain:i,moduleId:I};if(d.hot._main)return{type:"unaccepted",chain:i,moduleId:I};for(var c=0;c<d.parents.length;c++){var s=d.parents[c],b=r[s];if(b){if(b.hot._declinedDependencies[I])return{type:"declined",chain:i.concat([s]),moduleId:I,parentId:s};-1===e.indexOf(s)&&(b.hot._acceptedDependencies[I]?(t[s]||(t[s]=[]),a(t[s],[I])):(delete t[s],e.push(s),l.push({chain:i.concat([s]),id:s})))}}}}return{type:"accepted",moduleId:n,outdatedModules:e,outdatedDependencies:t}}function a(n,e){for(var t=0;t<e.length;t++){var l=e[t];-1===n.indexOf(l)&&n.push(l)}}e=e||{};var o={},A=[],Z={},Q=function(){console.warn("[HMR] unexpected require("+V.moduleId+") to disposed module")};for(var m in C)if(Object.prototype.hasOwnProperty.call(C,m)){var V;s=F(m);var X=!1,p=!1,W=!1,y="";switch((V=C[m]?b(s):{type:"disposed",moduleId:m}).chain&&(y="\nUpdate propagation: "+V.chain.join(" -> ")),V.type){case"self-declined":e.onDeclined&&e.onDeclined(V),e.ignoreDeclined||(X=new Error("Aborted because of self decline: "+V.moduleId+y));break;case"declined":e.onDeclined&&e.onDeclined(V),e.ignoreDeclined||(X=new Error("Aborted because of declined dependency: "+V.moduleId+" in "+V.parentId+y));break;case"unaccepted":e.onUnaccepted&&e.onUnaccepted(V),e.ignoreUnaccepted||(X=new Error("Aborted because "+s+" is not accepted"+y));break;case"accepted":e.onAccepted&&e.onAccepted(V),p=!0;break;case"disposed":e.onDisposed&&e.onDisposed(V),W=!0;break;default:throw new Error("Unexception type "+V.type)}if(X)return G("abort"),Promise.reject(X);if(p)for(s in Z[s]=C[s],a(A,V.outdatedModules),V.outdatedDependencies)Object.prototype.hasOwnProperty.call(V.outdatedDependencies,s)&&(o[s]||(o[s]=[]),a(o[s],V.outdatedDependencies[s]));W&&(a(A,[V.moduleId]),Z[s]=Q)}var R,N=[];for(l=0;l<A.length;l++)s=A[l],r[s]&&r[s].hot._selfAccepted&&N.push({module:s,errorHandler:r[s].hot._selfAccepted});G("dispose"),Object.keys(h).forEach(function(n){!1===h[n]&&function(n){delete installedChunks[n]}(n)});for(var v,x,E=A.slice();E.length>0;)if(s=E.pop(),d=r[s]){var H={},S=d.hot._disposeHandlers;for(I=0;I<S.length;I++)(t=S[I])(H);for(i[s]=H,d.hot.active=!1,delete r[s],delete o[s],I=0;I<d.children.length;I++){var T=r[d.children[I]];T&&((R=T.parents.indexOf(s))>=0&&T.parents.splice(R,1))}}for(s in o)if(Object.prototype.hasOwnProperty.call(o,s)&&(d=r[s]))for(x=o[s],I=0;I<x.length;I++)v=x[I],(R=d.children.indexOf(v))>=0&&d.children.splice(R,1);for(s in G("apply"),g=u,Z)Object.prototype.hasOwnProperty.call(Z,s)&&(n[s]=Z[s]);var O=null;for(s in o)if(Object.prototype.hasOwnProperty.call(o,s)&&(d=r[s])){x=o[s];var Y=[];for(l=0;l<x.length;l++)if(v=x[l],t=d.hot._acceptedDependencies[v]){if(-1!==Y.indexOf(t))continue;Y.push(t)}for(l=0;l<Y.length;l++){t=Y[l];try{t(x)}catch(n){e.onErrored&&e.onErrored({type:"accept-errored",moduleId:s,dependencyId:x[l],error:n}),e.ignoreErrored||O||(O=n)}}}for(l=0;l<N.length;l++){var z=N[l];s=z.module,c=[s];try{U(s)}catch(n){if("function"==typeof z.errorHandler)try{z.errorHandler(n)}catch(t){e.onErrored&&e.onErrored({type:"self-accept-error-handler-errored",moduleId:s,error:t,originalError:n}),e.ignoreErrored||O||(O=t),O||(O=n)}else e.onErrored&&e.onErrored({type:"self-accept-errored",moduleId:s,error:n}),e.ignoreErrored||O||(O=n)}}return O?(G("fail"),Promise.reject(O)):(G("idle"),new Promise(function(n){n(A)}))}var r={};function U(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{},hot:b(e),parents:(d=c,c=[],d),children:[]};return n[e].call(t.exports,t,t.exports,s(e)),t.l=!0,t.exports}U.m=n,U.c=r,U.d=function(n,e,t){U.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},U.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},U.t=function(n,e){if(1&e&&(n=U(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(U.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var l in n)U.d(t,l,function(e){return n[e]}.bind(null,l));return t},U.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return U.d(e,"a",e),e},U.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},U.p="/",U.h=function(){return g},s(0)(U.s=0)}([function(n,e,t){n.exports=t(3)},function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvd2FuZ3lvbmdxaW5nMDEvd3d3L2dpdC9ub2RlcHB0L3BhY2thZ2VzL25vZGVwcHQtc2VydmUvbm9kZV9tb2R1bGVzL25vZGVwcHQtanMvYXNzZXRzL3Njc3MvZnVsbC5zY3NzPzI4Y2MiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n")},function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvd2FuZ3lvbmdxaW5nMDEvd3d3L2dpdC9ub2RlcHB0L3BhY2thZ2VzL25vZGVwcHQtc2VydmUvbm9kZV9tb2R1bGVzL25vZGVwcHQtanMvYXNzZXRzL3Njc3MvaW5kZXguc2Nzcz9iZTg0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: /Users/wangyongqing01/www/git/nodeppt/packages/nodeppt-serve/node_modules/nodeppt-js/node_modules/webslides/src/js/utils/custom-event.js\nconst NativeCustomEvent = window.CustomEvent;\n/**\n * Check for the usage of native support for CustomEvents which is lacking\n * completely on IE.\n * @return {boolean} Whether it can be used or not.\n */\n\nfunction canIuseNativeCustom() {\n  try {\n    const p = new NativeCustomEvent('t', {\n      detail: {\n        a: 'b'\n      }\n    });\n    return 't' === p.type && 'b' === p.detail.a;\n  } catch (e) {}\n  /* istanbul ignore next: hard to reproduce on test environment  */\n\n\n  return false;\n}\n/**\n * Lousy polyfill for the Custom Event constructor for IE.\n * @param {!string} type The type of the event.\n * @param {?Object} params Additional information for the event.\n * @return {Event}\n * @constructor\n */\n\n/* istanbul ignore next: hard to reproduce on test environment  */\n\n\nconst IECustomEvent = function CustomEvent(type, params) {\n  const e = document.createEvent('CustomEvent');\n\n  if (params) {\n    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);\n  } else {\n    e.initCustomEvent(type, false, false, undefined);\n  }\n\n  return e;\n};\n/* istanbul ignore next: hard to reproduce on test environment  */\n\n\nconst WSCustomEvent = canIuseNativeCustom() ? NativeCustomEvent : IECustomEvent;\n/* harmony default export */ var custom_event = (WSCustomEvent);\n// CONCATENATED MODULE: /Users/wangyongqing01/www/git/nodeppt/packages/nodeppt-serve/node_modules/nodeppt-js/node_modules/webslides/src/js/utils/dom.js\n\nlet transitionEvent = '';\nlet animationEvent = '';\n/**\n * Static class for DOM helper.\n */\n\nclass dom_DOM {\n  /**\n   * Creates a node with optional parameters.\n   * @param {string} tag The name of the tag of the needed element.\n   * @param {string} id The desired id for the element. It defaults to an\n   * empty string.\n   * @param {string} text The desired text to go inside of the element. It\n   * defaults to an empty string.\n   * @return {Element}\n   */\n  static createNode(tag, id = '', text = '') {\n    const node = document.createElement(tag);\n\n    if (id) {\n      node.id = id;\n    }\n\n    if (text) {\n      node.textContent = text;\n    }\n\n    return node;\n  }\n  /**\n   * Listens for an event once.\n   * @param {Element} el Element to listen to.\n   * @param {string} event Event Type.\n   * @param {Function} callback Function to execute once the event fires.\n   */\n\n\n  static once(el, event, callback) {\n    const cb = e => {\n      if (e.target === el) {\n        el.removeEventListener(event, cb);\n        callback(e);\n      }\n    };\n\n    el.addEventListener(event, cb, false);\n  }\n  /**\n   * Gets the prefixed transitionend event.\n   * @param {?Element} optEl Element to check\n   * @return {string}\n   */\n\n\n  static getTransitionEvent(optEl) {\n    if (transitionEvent && !optEl) {\n      return transitionEvent;\n    }\n\n    transitionEvent = '';\n    const el = optEl || document.createElement('ws');\n    const transitions = {\n      'transition': 'transitionend',\n      'OTransition': 'oTransitionEnd',\n      'MozTransition': 'transitionend',\n      'WebkitTransition': 'webkitTransitionEnd'\n    };\n    const transitionNames = Object.keys(transitions);\n\n    for (let i = 0, length = transitionNames.length; i < length && !transitionEvent; i++) {\n      const transitionName = transitionNames[i];\n\n      if (typeof el.style[transitionName] !== 'undefined') {\n        transitionEvent = transitions[transitionName];\n      }\n    }\n\n    return transitionEvent;\n  }\n  /**\n   * Gets the prefixed animation end event.\n   * @param {?Element} optEl Element to check\n   * @return {string}\n   */\n\n\n  static getAnimationEvent(optEl) {\n    if (animationEvent && !optEl) {\n      return animationEvent;\n    }\n\n    animationEvent = 'animationend';\n    const el = optEl || document.createElement('ws');\n    const animations = {\n      'animation': 'animationend',\n      'OAnimation': 'oAnimationEnd',\n      'MozAnimation': 'animationend',\n      'WebkitAnimation': 'webkitAnimationEnd'\n    };\n    const animationNames = Object.keys(animations);\n\n    for (let i = 0, length = animationNames.length; i < length; i++) {\n      const animationName = animationNames[i];\n\n      if (typeof el.style[animationName] !== 'undefined') {\n        animationEvent = animations[animationName];\n        break;\n      }\n    }\n\n    return animationEvent;\n  }\n  /**\n   * Hides an element setting the display to none.\n   * @param {Element} el Element to be hidden.\n   */\n\n\n  static hide(el) {\n    el.style.display = 'none';\n  }\n  /**\n   * Shows an element by removing the display property. This is only intended\n   * to be used in conjunction with DOM.hide.\n   * @param {Element} el Element to be shown.\n   */\n\n\n  static show(el) {\n    el.style.display = '';\n  }\n  /**\n   * Checks if the element is visible.\n   * @param {Element} el Element to check.\n   * @return {boolean}\n   */\n\n\n  static isVisible(el) {\n    return el.offsetParent !== null;\n  }\n  /**\n   * Fires a custom event on the given target.\n   * @param {Element} target The target of the event.\n   * @param {string} eventType The event type.\n   * @param {Object} eventInfo Optional parameter to provide additional data\n   * to the event.\n   */\n\n\n  static fireEvent(target, eventType, eventInfo = {}) {\n    const event = new custom_event(eventType, {\n      detail: eventInfo\n    });\n    target.dispatchEvent(event);\n  }\n  /**\n   * Converts an iterable to an array.\n   * @param {*} iterable Element to convert to array\n   * @return {Array} the element casted to an array.\n   */\n\n\n  static toArray(iterable) {\n    return [].slice.call(iterable);\n  }\n  /**\n   * Checks whether the document has focus on an input or contenteditable\n   * element.\n   * @return {boolean} Whether the focused element is an input or content\n   * editable.\n   */\n\n\n  static isFocusableElement() {\n    let result = false;\n\n    if (document.activeElement) {\n      const isContentEditable = document.activeElement.contentEditable !== 'inherit' && document.activeElement.contentEditable !== undefined;\n      const isInput = ['INPUT', 'SELECT', 'OPTION', 'TEXTAREA'].indexOf(document.activeElement.tagName) > -1;\n      result = isInput || isContentEditable;\n    }\n\n    return result;\n  }\n  /**\n   * Gets the integer value of a style property.\n   * @param {string} prop CSS property value.\n   * @return {Number} The property without the units.\n   */\n\n\n  static parseSize(prop) {\n    return Number(prop.replace(/[^\\d\\.]/g, ''));\n  }\n  /**\n   * Wraps a HTML structure around an element.\n   * @param {Element} elem the element to be wrapped.\n   * @param {string} tag the new element tag.\n   * @return {Element} the new element.\n   */\n\n\n  static wrap(elem, tag) {\n    const wrap = document.createElement(tag);\n    elem.parentElement.insertBefore(wrap, elem);\n    wrap.appendChild(elem);\n    return wrap;\n  }\n  /**\n   * Inserts and element after another element.\n   * @param {Element} elem the element to be inserted.\n   * @param {Element} target the element to be inserted after.\n   */\n\n\n  static after(elem, target) {\n    const parent = target.parentNode;\n\n    if (parent.lastChild === target) {\n      parent.appendChild(elem);\n    } else {\n      parent.insertBefore(elem, target.nextSibling);\n    }\n  }\n\n}\n// CONCATENATED MODULE: /Users/wangyongqing01/www/git/nodeppt/packages/nodeppt-serve/node_modules/nodeppt-js/node_modules/webslides/src/js/plugins/autoslide.js\n\n/**\n * Autoslide plugin.\n */\n\nclass autoslide_AutoSlide {\n  /**\n   * @param {WebSlides} wsInstance The WebSlides instance\n   * @constructor\n   */\n  constructor(wsInstance) {\n    /**\n     * @type {WebSlides}\n     * @private\n     */\n    this.ws_ = wsInstance;\n    /**\n     * Interval ID reference for the autoslide.\n     * @type {?number}\n     * @private\n     */\n\n    this.interval_ = null;\n    /**\n     * Internal stored time.\n     * @type {?number}\n     */\n\n    this.time = this.ws_.options.autoslide;\n\n    if (this.time) {\n      dom_DOM.once(wsInstance.el, 'ws:init', this.play.bind(this));\n      document.body.addEventListener('focus', this.onFocus.bind(this));\n    }\n  }\n  /**\n   * On focus handler. Will decide if stops/play depending on the focused\n   * element if autoslide is active.\n   */\n\n\n  onFocus() {\n    if (dom_DOM.isFocusableElement()) {\n      this.stop();\n    } else if (this.interval_ === null) {\n      this.play();\n    }\n  }\n  /**\n   * Starts autosliding all the slides if it's not currently doing it and the\n   * autoslide option was a number greater than 0.\n   * @param {?number=} time Amount of milliseconds to wait to go to next slide\n   * automatically.\n   */\n\n\n  play(time) {\n    if (typeof time !== 'number') {\n      time = this.time;\n    }\n\n    this.time = time;\n\n    if (!this.interval_ && typeof time === 'number' && time > 0) {\n      this.interval_ = setInterval(this.ws_.goNext.bind(this.ws_), time);\n    }\n  }\n  /**\n   * Stops autosliding all the slides.\n   */\n\n\n  stop() {\n    if (this.interval_) {\n      clearInterval(this.interval_);\n      this.interval_ = null;\n    }\n  }\n\n}\n// CONCATENATED MODULE: /Users/wangyongqing01/www/git/nodeppt/packages/nodeppt-serve/node_modules/nodeppt-js/node_modules/webslides/src/js/plugins/click-nav.js\nconst CLICKABLE_ELS = ['INPUT', 'SELECT', 'OPTION', 'BUTTON', 'A', 'TEXTAREA'];\n/**\n * ClickNav plugin that allows to click on the page to get to the next slide.\n */\n\nclass ClickNav {\n  /**\n   * @param {WebSlides} wsInstance The WebSlides instance\n   * @constructor\n   */\n  constructor(wsInstance) {\n    /**\n     * @type {WebSlides}\n     * @private\n     */\n    this.ws_ = wsInstance;\n\n    if (wsInstance.options.changeOnClick) {\n      this.ws_.el.addEventListener('click', this.onClick_.bind(this));\n    }\n  }\n  /**\n   * Reacts to the click event. It will go to the next slide unless the element\n   * has a data-prevent-nav attribute or is on the list of CLICKABLE_ELS.\n   * @param {MouseEvent} event The click event.\n   * @private\n   */\n\n\n  onClick_(event) {\n    if (CLICKABLE_ELS.indexOf(event.target.tagName) < 0 && typeof event.target.dataset.preventNav === 'undefined') {\n      this.ws_.goNext();\n    }\n  }\n\n}\n// CONCATENATED MODULE: /Users/wangyongqing01/www/git/nodeppt/packages/nodeppt-serve/node_modules/nodeppt-js/node_modules/webslides/src/js/utils/keys.js\nconst Keys = {\n  ENTER: 13,\n  SPACE: 32,\n  RE_PAGE: 33,\n  AV_PAGE: 34,\n  END: 35,\n  HOME: 36,\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40,\n  PLUS: [107, 171, 187],\n  MINUS: [109, 173, 189],\n  ESCAPE: 27,\n  F: 70\n};\n/* harmony default export */ var keys = (Keys);\n// CONCATENATED MODULE: /Users/wangyongqing01/www/git/nodeppt/packages/nodeppt-serve/node_modules/nodeppt-js/node_modules/webslides/src/js/plugins/grid.js\n\nconst GRID_IMAGE = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYAg' + 'MAAACdGdVrAAAACVBMVEUAAAAtXsUtXcPDDPUWAAAAA3RSTlMAZmHzZFkxAAAAFklEQVQI12M' + 'AA9bBR3ExhAJB1iooBQBGwgVEs/QtuAAAAABJRU5ErkJggg==';\n/**\n * Grid plugin that shows a grid on top of the WebSlides for easy prototyping.\n */\n\nclass grid_Grid {\n  /**\n   * @param {WebSlides} wsInstance The WebSlides instance\n   * @constructor\n   */\n  constructor(wsInstance) {\n    /**\n     * @type {WebSlides}\n     * @private\n     */\n    this.ws_ = wsInstance;\n    const CSS = `body.baseline {\n                  background: url(${GRID_IMAGE}) left top .8rem/.8rem;\n                }`;\n    const head = document.head || document.getElementsByTagName('head')[0];\n    const style = document.createElement('style');\n    style.type = 'text/css';\n\n    if (style.styleSheet) {\n      style.styleSheet.cssText = CSS;\n    } else {\n      style.appendChild(document.createTextNode(CSS));\n    }\n\n    head.appendChild(style);\n    document.addEventListener('keydown', this.onKeyPress_.bind(this), false);\n  }\n  /**\n   * Reacts to the keydown event. It reacts to ENTER key to toggle the class.\n   * @param {KeyboardEvent} event The key event.\n   * @private\n   */\n\n\n  onKeyPress_(event) {\n    if (event.which === keys.ENTER) {\n      document.body.classList.toggle('baseline');\n    }\n  }\n\n}\n// CONCATENATED MODULE: /Users/wangyongqing01/www/git/nodeppt/packages/nodeppt-serve/node_modules/nodeppt-js/node_modules/webslides/src/js/plugins/hash.js\nconst HASH = '#slide';\nconst slideRegex = /#slide=(\\d+)/;\n/**\n * Static class with methods to manipulate and extract info from the hash of\n * the URL.\n */\n\nclass Hash {\n  /**\n   * @param {WebSlides} wsInstance\n   * @constructor\n   */\n  constructor(wsInstance) {\n    this.ws_ = wsInstance;\n    wsInstance.el.addEventListener('ws:slide-change', Hash.onSlideChange_);\n    window.addEventListener('hashchange', this.onHashChange_.bind(this), false);\n  }\n  /**\n   * hashchange event handler, makes the WebSlide instance navigate to the\n   * needed slide.\n   */\n\n\n  onHashChange_() {\n    const newSlideIndex = Hash.getSlideNumber();\n\n    if (newSlideIndex !== null) {\n      this.ws_.goToSlide(newSlideIndex);\n    }\n  }\n  /**\n   * Handler for the slide change event which updates the slide on the hash.\n   * @param {Event} event\n   * @private\n   */\n\n\n  static onSlideChange_(event) {\n    Hash.setSlideNumber(event.detail.currentSlide);\n  }\n  /**\n   * Gets the slide number from the hash by a regex matching `#slide=` and gets\n   * the number after it. If the number is invalid or less than 0, it will\n   * return null as an invalid value.\n   * @return {?number}\n   */\n\n\n  static getSlideNumber() {\n    const results = document.location.hash.match(slideRegex);\n    let slide = 0;\n\n    if (Array.isArray(results)) {\n      slide = parseInt(results[1], 10);\n    }\n\n    if (typeof slide !== 'number' || slide < 0 || !Array.isArray(results)) {\n      slide = null;\n    } else {\n      slide--; // Convert to 0 index\n    }\n\n    return slide;\n  }\n  /**\n   * It will update the hash (if it's different) so it reflects the slide\n   * number being visible.\n   * @param {number} number The number of the slide we're transitioning to.\n   */\n\n\n  static setSlideNumber(number) {\n    if (Hash.getSlideNumber() !== number - 1) {\n      history.pushState({\n        slideI: number - 1\n      }, `Slide ${number}`, `${HASH}=${number}`);\n    }\n  }\n\n}\n// CONCATENATED MODULE: /Users/wangyongqing01/www/git/nodeppt/packages/nodeppt-serve/node_modules/nodeppt-js/node_modules/webslides/src/js/plugins/keyboard.js\n\n\n/**\n * Keyboard interaction plugin.\n */\n\nclass keyboard_Keyboard {\n  /**\n   * @param {WebSlides} wsInstance The WebSlides instance\n   * @constructor\n   */\n  constructor(wsInstance) {\n    /**\n     * @type {WebSlides}\n     * @private\n     */\n    this.ws_ = wsInstance;\n    document.addEventListener('keydown', this.onKeyPress_.bind(this), false);\n  }\n  /**\n   * Reacts to the keydown event. It reacts to the arrows and space key\n   * depending on the layout of the page.\n   * @param {KeyboardEvent} event The key event.\n   * @private\n   */\n\n\n  onKeyPress_(event) {\n    let method;\n    let argument;\n\n    if (dom_DOM.isFocusableElement() || this.ws_.isDisabled()) {\n      return;\n    }\n\n    switch (event.which) {\n      case keys.AV_PAGE:\n      case keys.SPACE:\n        method = this.ws_.goNext;\n        break;\n\n      case keys.RE_PAGE:\n        method = this.ws_.goPrev;\n        break;\n\n      case keys.HOME:\n        method = this.ws_.goToSlide;\n        argument = 0;\n        break;\n\n      case keys.END:\n        method = this.ws_.goToSlide;\n        argument = this.ws_.maxSlide_ - 1;\n        break;\n\n      case keys.DOWN:\n        method = this.ws_.isVertical ? this.ws_.goNext : null;\n        break;\n\n      case keys.UP:\n        method = this.ws_.isVertical ? this.ws_.goPrev : null;\n        break;\n\n      case keys.LEFT:\n        method = !this.ws_.isVertical ? this.ws_.goPrev : null;\n        break;\n\n      case keys.RIGHT:\n        method = !this.ws_.isVertical ? this.ws_.goNext : null;\n        break;\n\n      case keys.F:\n        method = this.ws_.fullscreen;\n        break;\n    }\n\n    if (method) {\n      method.call(this.ws_, argument); // Prevents Firefox key events.\n\n      event.preventDefault();\n    }\n  }\n\n}\n// CONCATENATED MODULE: /Users/wangyongqing01/www/git/nodeppt/packages/nodeppt-serve/node_modules/nodeppt-js/node_modules/webslides/src/js/plugins/navigation.js\n\nconst ELEMENT_ID = {\n  NAV: 'navigation',\n  NEXT: 'next',\n  PREV: 'previous',\n  COUNTER: 'counter'\n};\nconst LABELS = {\n  VERTICAL: {\n    NEXT: '↓',\n    PREV: '↑'\n  },\n  HORIZONTAL: {\n    NEXT: '→',\n    PREV: '←'\n  }\n};\n/**\n * Navigation plugin.\n */\n\nclass navigation_Navigation {\n  /**\n   * @param {WebSlides} wsInstance The WebSlides instance\n   * @constructor\n   */\n  constructor(wsInstance) {\n    const arrowLabels = wsInstance.isVertical ? LABELS.VERTICAL : LABELS.HORIZONTAL;\n    /**\n     * Navigation element.\n     * @type {Element}\n     */\n\n    this.el = dom_DOM.createNode('div', 'navigation');\n    /**\n     * Next button.\n     * @type {Element}\n     */\n\n    this.next = navigation_Navigation.createArrow(ELEMENT_ID.NEXT, arrowLabels.NEXT);\n    /**\n     * Prev button.\n     * @type {Element}\n     */\n\n    this.prev = navigation_Navigation.createArrow(ELEMENT_ID.PREV, arrowLabels.PREV);\n    /**\n     * Counter Element.\n     * @type {Element}\n     */\n\n    this.counter = navigation_Navigation.createCounter(ELEMENT_ID.COUNTER, wsInstance);\n    /**\n     * @type {WebSlides}\n     * @private\n     */\n\n    this.ws_ = wsInstance;\n    this.el.appendChild(this.next);\n    this.el.appendChild(this.prev);\n    this.el.appendChild(this.counter);\n    this.ws_.el.appendChild(this.el);\n    this.bindEvents_();\n  }\n  /**\n   * Bind all events for the navigation.\n   * @private\n   */\n\n\n  bindEvents_() {\n    this.ws_.el.addEventListener('ws:slide-change', this.onSlideChanged_.bind(this));\n    this.next.addEventListener('click', this.onButtonClicked_.bind(this));\n    this.prev.addEventListener('click', this.onButtonClicked_.bind(this));\n    this.counter.addEventListener('click', this.onButtonClicked_.bind(this));\n  }\n  /**\n   * Updates the counter inside the navigation.\n   * @param {string|number} current Current slide number.\n   * @param {string|number} max Max slide number.\n   */\n\n\n  updateCounter(current, max) {\n    if (this.ws_.options.showIndex) {\n      this.counter.childNodes[0].textContent = `${current} / ${max}`;\n    } else {\n      this.counter.textContent = `${current} / ${max}`;\n    }\n  }\n  /**\n   * Creates an arrow to navigate.\n   * @param {!String} id Desired ID for the arrow.\n   * @param {!String} text Desired text for the arrow.\n   * @return {Element} The arrow element.\n   */\n\n\n  static createArrow(id, text) {\n    const arrow = dom_DOM.createNode('a', id, text);\n    arrow.href = '#';\n    arrow.title = 'Arrow Keys';\n    return arrow;\n  }\n  /**\n   * Creates the navigation counter.\n   * @param {!String} id Desired ID for the counter.\n   * @param {WebSlides} ws_ WebSlides object.\n   * @return {Element} The arrow element.\n   */\n\n\n  static createCounter(id, ws_) {\n    const counter = dom_DOM.createNode('span', id);\n\n    if (ws_.options.showIndex) {\n      const link = document.createElement('a');\n      link.href = '#';\n      link.title = 'View all slides';\n      counter.appendChild(link);\n    }\n\n    return counter;\n  }\n  /**\n   * Slide Change event handler. Will update the text on the navigation.\n   * @param {CustomEvent} event\n   * @private\n   */\n\n\n  onSlideChanged_(event) {\n    this.updateCounter(event.detail.currentSlide, event.detail.slides);\n  }\n  /**\n   * Handles clicks on the next/prev buttons.\n   * @param {MouseEvent} event\n   * @private\n   */\n\n\n  onButtonClicked_(event) {\n    event.preventDefault();\n\n    if (event.target === this.next) {\n      this.ws_.goNext();\n    } else if (event.target === this.prev) {\n      this.ws_.goPrev();\n    } else {\n      this.ws_.toggleZoom();\n    }\n  }\n\n}\n// CONCATENATED MODULE: /Users/wangyongqing01/www/git/nodeppt/packages/nodeppt-serve/node_modules/nodeppt-js/node_modules/webslides/src/js/utils/mobile-detector.js\nconst UA = window.navigator.userAgent;\n/**\n * Mobile detector helper class. Tests the User Agent to see if we're, likely,\n * on a mobile device.\n */\n\nclass MobileDetector {\n  /**\n   * Whether the device is Android or not.\n   * @return {Boolean}\n   */\n  static isAndroid() {\n    return !!UA.match(/Android/i);\n  }\n  /**\n   * Whether the device is BlackBerry or not.\n   * @return {Boolean}\n   */\n\n\n  static isBlackBerry() {\n    return !!UA.match(/BlackBerry/i);\n  }\n  /**\n   * Whether the device is iOS or not.\n   * @return {Boolean}\n   */\n\n\n  static isiOS() {\n    return !!UA.match(/iPad|iPhone|iPod/i);\n  }\n  /**\n   * Whether the device is Opera or not.\n   * @return {Boolean}\n   */\n\n\n  static isOpera() {\n    return !!UA.match(/Opera Mini/i);\n  }\n  /**\n   * Whether the device is Windows or not.\n   * @return {Boolean}\n   */\n\n\n  static isWindows() {\n    return !!UA.match(/IEMobile/i);\n  }\n  /**\n   * Whether the device is Windows Phone or not.\n   * @return {Boolean}\n   */\n\n\n  static isWindowsPhone() {\n    return !!UA.match(/Windows Phone/i);\n  }\n  /**\n   * Whether the device is any mobile device or not.\n   * @return {Boolean}\n   */\n\n\n  static isAny() {\n    return MobileDetector.isAndroid() || MobileDetector.isBlackBerry() || MobileDetector.isiOS() || MobileDetector.isOpera() || MobileDetector.isWindows() || MobileDetector.isWindowsPhone();\n  }\n\n}\n// CONCATENATED MODULE: /Users/wangyongqing01/www/git/nodeppt/packages/nodeppt-serve/node_modules/nodeppt-js/node_modules/webslides/src/js/plugins/scroll.js\n\n/**\n * Scroll plugin.\n */\n\nclass scroll_Scroll {\n  /**\n   * @param {WebSlides} wsInstance The WebSlides instance\n   * @constructor\n   */\n  constructor(wsInstance) {\n    /**\n     * @type {WebSlides}\n     * @private\n     */\n    this.ws_ = wsInstance;\n    /**\n     * Where the scroll is going to happen. The WebSlides element.\n     * @type {Element}\n     * @private\n     */\n\n    this.scrollContainer_ = wsInstance.el;\n    /**\n     * Whether movement is happening up or down.\n     * @type {boolean}\n     * @private\n     */\n\n    this.isGoingUp_ = false;\n    /**\n     * Whether movement is happening left or right.\n     * @type {boolean}\n     * @private\n     */\n\n    this.isGoingLeft_ = false;\n    /**\n     * Timeout id holder.\n     * @type {?number}\n     * @private\n     */\n\n    this.timeout_ = null; // Disabling from option\n\n    if (!this.ws_.options.navigateOnScroll) {\n      return;\n    }\n\n    if (!MobileDetector.isAny()) {\n      this.scrollContainer_.addEventListener('wheel', this.onMouseWheel_.bind(this));\n\n      if (!wsInstance.isVertical) {\n        wsInstance.el.addEventListener('ws:slide-change', this.onSlideChange_.bind(this));\n      }\n    }\n  }\n  /**\n   * When the slides change, set an inner timeout to avoid prematurely\n   * changing to the next slide again.\n   * @private\n   */\n\n\n  onSlideChange_() {\n    this.timeout_ = setTimeout(() => {\n      this.timeout_ = null;\n    }, this.ws_.options.scrollWait);\n  }\n  /**\n   * Reacts to the wheel event. Detects whether is going up or down and decides\n   * if it needs to move the slide based on the amount of delta.\n   * @param {WheelEvent} event The Wheel Event.\n   * @private\n   */\n\n\n  onMouseWheel_(event) {\n    if (this.ws_.isDisabled()) {\n      return;\n    }\n\n    if (this.ws_.isMoving || this.timeout_) {\n      event.preventDefault();\n      return;\n    } // Firefox uses lines instead of pixels for delta\n\n\n    const linesToPx = event.deltaMode * this.ws_.options.minWheelDelta;\n    const {\n      deltaY: wheelDeltaY,\n      deltaX: wheelDeltaX\n    } = event;\n    const isVertical = this.ws_.isVertical;\n    const isHorizontalMovement = Math.abs(wheelDeltaX) > Math.abs(wheelDeltaY);\n    this.isGoingUp_ = wheelDeltaY < 0;\n    this.isGoingLeft_ = wheelDeltaX < 0; // If we're mainly moving horizontally, prevent default\n\n    if (isHorizontalMovement) {\n      if (!isVertical) {\n        event.preventDefault();\n      } else {\n        // If we're moving horizontally but this is vertical, return to avoid\n        // unwanted navigation.\n        return;\n      }\n    }\n\n    if (Math.abs(wheelDeltaY + linesToPx) >= this.ws_.options.minWheelDelta || Math.abs(wheelDeltaX + linesToPx) >= this.ws_.options.minWheelDelta) {\n      if (isHorizontalMovement && this.isGoingLeft_ || !isHorizontalMovement && this.isGoingUp_) {\n        this.ws_.goPrev();\n      } else {\n        this.ws_.goNext();\n      }\n\n      event.preventDefault();\n    }\n  }\n\n}\n// CONCATENATED MODULE: /Users/wangyongqing01/www/git/nodeppt/packages/nodeppt-serve/node_modules/nodeppt-js/node_modules/webslides/src/js/plugins/touch.js\n\nconst EVENTS = {\n  touch: {\n    START: 'touchstart',\n    MOVE: 'touchmove',\n    END: 'touchend'\n  },\n  pointer: {\n    START: 'pointerdown',\n    MOVE: 'pointermove',\n    END: 'pointerup'\n  }\n};\n/**\n * Touch plugin.\n */\n\nclass touch_Touch {\n  /**\n   * @param {WebSlides} wsInstance The WebSlides instance\n   * @constructor\n   */\n  constructor(wsInstance) {\n    /**\n     * @type {WebSlides}\n     * @private\n     */\n    this.ws_ = wsInstance;\n    /**\n     * Start position for the X coordinate.\n     * @type {number}\n     * @private\n     */\n\n    this.startX_ = 0;\n    /**\n     * Start position for the Y coordinate.\n     * @type {number}\n     * @private\n     */\n\n    this.startY_ = 0;\n    /**\n     * Start position for the X coord.\n     * @type {number}\n     * @private\n     */\n\n    this.endX_ = 0;\n    /**\n     * Start position for the Y coord.\n     * @type {number}\n     * @private\n     */\n\n    this.endY_ = 0;\n    /**\n     * Whether is enabled or not. Only enabled for touch devices.\n     * @type {boolean}\n     * @private\n     */\n\n    this.isEnabled = false;\n    /**\n     * Whether is a gesture or not.\n     * @type {boolean}\n     * @private\n     */\n\n    this.isGesture = false;\n    /**\n     * Stores start touch event (x, y).\n     * @type {array}\n     * @private\n     */\n\n    this.startTouches = [];\n    /**\n     * Stores end touch event (x, y).\n     * @type {array}\n     * @private\n     */\n\n    this.endTouches = [];\n    let events;\n\n    if (MobileDetector.isAny()) {\n      // Likely IE\n      if (window.PointerEvent && (MobileDetector.isWindows() || MobileDetector.isWindowsPhone())) {\n        events = EVENTS.pointer;\n      } else {\n        events = EVENTS.touch;\n      }\n\n      this.isEnabled = true;\n      document.addEventListener(events.START, this.onStart_.bind(this), false);\n      document.addEventListener(events.MOVE, this.onMove_.bind(this), false);\n      document.addEventListener(events.END, this.onStop_.bind(this), false);\n    }\n  }\n  /**\n   * Start touch handler. Saves starting points.\n   * @param {Event} event The Touch event.\n   * @private\n   */\n\n\n  onStart_(event) {\n    if (this.ws_.isDisabled()) {\n      return;\n    }\n\n    const info = touch_Touch.normalizeEventInfo(event);\n\n    if (event.touches.length === 1) {\n      this.startX_ = info.x;\n      this.startY_ = info.y;\n      this.endX_ = info.x;\n      this.endY_ = info.y;\n    } else if (event.touches.length > 1) {\n      this.startTouches = touch_Touch.getTouchCoordinates(event);\n      this.endTouches = this.startTouches;\n      this.isGesture = true;\n    }\n  }\n  /**\n   * Move touch handler. Saves end points.\n   * @param {Event} event The Touch event.\n   * @private\n   */\n\n\n  onMove_(event) {\n    if (this.ws_.isDisabled()) {\n      return;\n    }\n\n    const info = touch_Touch.normalizeEventInfo(event);\n\n    if (this.isGesture) {\n      this.endTouches = touch_Touch.getTouchCoordinates(event);\n    } else {\n      this.endX_ = info.x;\n      this.endY_ = info.y;\n    }\n  }\n  /**\n   * Stop touch handler. Checks if it needs to make any actions.\n   * @private\n   */\n\n\n  onStop_() {\n    if (this.ws_.isDisabled()) {\n      return;\n    }\n\n    if (this.isGesture) {\n      const startDistance = Math.sqrt(Math.pow(this.startTouches[0].x - this.startTouches[1].x, 2) + Math.pow(this.startTouches[0].y - this.startTouches[1].y, 2));\n      const endDistance = Math.sqrt(Math.pow(this.endTouches[0].x - this.endTouches[1].x, 2) + Math.pow(this.endTouches[0].y - this.endTouches[1].y, 2));\n\n      if (startDistance > endDistance) {\n        // Pinch gesture\n        this.ws_.toggleZoom();\n      }\n\n      this.isGesture = false;\n    } else {\n      const diffX = this.startX_ - this.endX_;\n      const diffY = this.startY_ - this.endY_; // It's an horizontal drag\n\n      if (Math.abs(diffX) > Math.abs(diffY)) {\n        if (diffX < -this.ws_.options.slideOffset) {\n          this.ws_.goPrev();\n        } else if (diffX > this.ws_.options.slideOffset) {\n          this.ws_.goNext();\n        }\n      }\n    }\n  }\n  /**\n   * Get X,Y coordinates from touch pointers.\n   * @param {Event} event\n   * @return {Object}\n   */\n\n\n  static getTouchCoordinates(event) {\n    return [{\n      x: event.touches[0].clientX,\n      y: event.touches[0].clientY\n    }, {\n      x: event.touches[1].clientX,\n      y: event.touches[1].clientY\n    }];\n  }\n  /**\n   * Normalizes an event to deal with differences between PointerEvent and\n   * TouchEvent.\n   * @param {Event} event\n   * @return {Object} Normalised touch points.\n   */\n\n\n  static normalizeEventInfo(event) {\n    let touchEvent = {\n      pageX: 0,\n      pageY: 0\n    };\n\n    if (typeof event.changedTouches !== 'undefined') {\n      touchEvent = event.changedTouches[0];\n    } else if (typeof event.originalEvent !== 'undefined' && typeof event.originalEvent.changedTouches !== 'undefined') {\n      touchEvent = event.originalEvent.changedTouches[0];\n    }\n\n    const x = event.offsetX || event.layerX || touchEvent.pageX;\n    const y = event.offsetY || event.layerY || touchEvent.pageY;\n    return {\n      x,\n      y\n    };\n  }\n\n}\n// CONCATENATED MODULE: /Users/wangyongqing01/www/git/nodeppt/packages/nodeppt-serve/node_modules/nodeppt-js/node_modules/webslides/src/js/modules/slide.js\n\nconst CLASSES = {\n  SLIDE: 'slide',\n  CURRENT: 'current'\n};\nconst Events = {\n  ENTER: 'dom:enter',\n  LEAVE: 'dom:leave',\n  ENABLE: 'slide:enable',\n  DISABLE: 'slide:disable'\n};\n/**\n * Wrapper for the Slide section.\n */\n\nclass slide_Slide {\n  /**\n   * Bootstraps the slide by saving some data, adding a class and hiding it.\n   * @param {Element} el Section element.\n   * @param {number} i Zero based index of the slide.\n   */\n  constructor(el, i) {\n    /**\n     * @type {Element}\n     */\n    this.el = el;\n    /**\n     * The section's parent.\n     * @type {Node}\n     */\n\n    this.parent = el.parentNode;\n    /**\n     * @type {number}\n     */\n\n    this.i = i;\n    this.el.id = `section-${i + 1}`;\n    this.el.classList.add(CLASSES.SLIDE); // Hide slides by default\n\n    this.hide();\n  }\n  /**\n   * Hides the node and removes the class that makes it \"active\".\n   */\n\n\n  hide() {\n    dom_DOM.hide(this.el);\n    this.el.classList.remove(CLASSES.CURRENT);\n  }\n  /**\n   * Shows the node and adds the class that makes it \"active\".\n   */\n\n\n  show() {\n    dom_DOM.show(this.el);\n    this.el.classList.add(CLASSES.CURRENT);\n  }\n  /**\n   * Moves the section to the bottom of the section's list.\n   * @fires Slide#dom:leave\n   * @fires Slide#dom:enter\n   */\n\n\n  moveAfterLast() {\n    const last = this.parent.childNodes[this.parent.childElementCount - 1];\n    this.fire_(Events.LEAVE);\n    this.parent.insertBefore(this.el, last.nextSibling);\n    this.fire_(Events.ENTER);\n  }\n  /**\n   * Moves the section to the top of the section's list.\n   * @fires Slide#dom:leave\n   * @fires Slide#dom:enter\n   */\n\n\n  moveBeforeFirst() {\n    const first = this.parent.childNodes[0];\n    this.fire_(Events.LEAVE);\n    this.parent.insertBefore(this.el, first);\n    this.fire_(Events.ENTER);\n  }\n  /**\n   * Fires an enable event.\n   * @fires Slide#slide:enable\n   */\n\n\n  enable() {\n    this.fire_(Events.ENABLE);\n  }\n  /**\n   * Fires a disable event.\n   * @fires Slide#slide:disable\n   */\n\n\n  disable() {\n    this.fire_(Events.DISABLE);\n  }\n  /**\n   * Fires an event passing the slide instance on the detail.\n   * @param {String} name Name of the event to fire.\n   * @private\n   */\n\n\n  fire_(name) {\n    dom_DOM.fireEvent(this.el, name, {\n      slide: this\n    });\n  }\n  /**\n   * Checks whether an element is a valid candidate to be a slide by ensuring\n   * it's a \"section\" element.\n   * @param {Element} el Element to be checked.\n   * @return {boolean} Whether is candidate or not.\n   */\n\n\n  static isCandidate(el) {\n    return el.nodeType === 1 && el.tagName === 'SECTION';\n  }\n  /**\n   * Gets the section element from an inner element.\n   * @param {Node} el\n   * @return {{section: ?Node, i: ?number}} A map with the section and the\n   * position of the section.\n   */\n\n\n  static getSectionFromEl(el) {\n    let parent = el;\n    let section = null;\n    let i = null;\n\n    while (parent.parentElement && !parent.classList.contains(CLASSES.SLIDE)) {\n      parent = parent.parentElement;\n    }\n\n    if (parent.classList.contains(CLASSES.SLIDE)) {\n      section = parent;\n      i = parseInt(section.id.replace('section-', ''), 10);\n    }\n\n    return {\n      section,\n      i\n    };\n  }\n\n}\n\n\n// CONCATENATED MODULE: /Users/wangyongqing01/www/git/nodeppt/packages/nodeppt-serve/node_modules/nodeppt-js/node_modules/webslides/src/js/plugins/video.js\n\n\n/**\n * Video plugin. Video plugin that allows to autoplay videos once the slide gets\n * active.\n */\n\nclass video_Video {\n  /**\n   * @param {WebSlides} wsInstance The WebSlides instance.\n   * @constructor\n   */\n  constructor(wsInstance) {\n    /**\n     * @type {WebSlides}\n     * @private\n     */\n    this.ws_ = wsInstance;\n    const videos = dom_DOM.toArray(this.ws_.el.querySelectorAll('video'));\n\n    if (videos.length) {\n      videos.forEach(video => {\n        if (!video.hasAttribute('autoplay')) {\n          return;\n        }\n\n        video.removeAttribute('autoplay');\n        video.pause();\n        video.currentTime = 0;\n        const {\n          i\n        } = slide_Slide.getSectionFromEl(video);\n        const slide = wsInstance.slides[i - 1];\n        slide.video = video;\n        slide.el.addEventListener(Events.ENABLE, video_Video.onSectionEnabled);\n        slide.el.addEventListener(Events.DISABLE, video_Video.onSectionDisabled);\n      });\n    }\n  }\n  /**\n   * On Section enable hook. Will play the video.\n   * @param {CustomEvent} event\n   */\n\n\n  static onSectionEnabled(event) {\n    event.detail.slide.video.play();\n  }\n  /**\n   * On Section enable hook. Will pause the video.\n   * @param {CustomEvent} event\n   */\n\n\n  static onSectionDisabled(event) {\n    event.detail.slide.video.pause();\n  }\n\n}\n// CONCATENATED MODULE: /Users/wangyongqing01/www/git/nodeppt/packages/nodeppt-serve/node_modules/nodeppt-js/node_modules/webslides/src/js/plugins/youtube.js\n/* global YT */\n\n\n/**\n * Player wrapper around the YT player. This is mostly to get around the event\n * in which we need to play a video which player isn't ready yet.\n */\n\nclass youtube_Player {\n  /**\n   * @param {Element} el\n   */\n  constructor(el) {\n    /**\n     * Whether the Player is ready or not.\n     * @type {boolean}\n     */\n    this.ready = false;\n    /**\n     * Ready callback.\n     * @type {?function}\n     */\n\n    this.onReadyCb = null;\n    /**\n     * Slide element in which the video is located.\n     * @type {Node}\n     */\n\n    this.slide = slide_Slide.getSectionFromEl(el).section;\n    /**\n     * Whether it should autoplay on load or not.\n     * @type {boolean}\n     */\n\n    this.autoplay = typeof el.dataset.autoplay !== 'undefined';\n    /**\n     * Whether the video should be muted or not.\n     * @type {boolean}\n     */\n\n    this.isMuted = typeof el.dataset.mute !== 'undefined';\n    /**\n     * Options with which the player is created.\n     * @type {Object}\n     */\n\n    this.options = {\n      videoId: el.dataset.youtubeId,\n      playerVars: this.getPlayerVars(el),\n      events: {\n        onReady: this.onPlayerReady.bind(this)\n      }\n    };\n    /**\n     * The iframe in which the video is loaded.\n     * @type {Element}\n     */\n\n    this.el = el;\n    /**\n     * Timeout id.\n     * @type {?number}\n     */\n\n    this.timeout = null;\n    this.create();\n  }\n  /**\n   * Destroys the iframe. Saves the current time in case it gets restored.\n   */\n\n\n  destroy() {\n    this.currentTime = this.player.getCurrentTime();\n    this.player.destroy();\n    this.player = null;\n    this.el = this.slide.querySelector('[data-youtube]');\n    this.ready = false;\n  }\n  /**\n   * Creates the player.\n   */\n\n\n  create() {\n    this.player = new YT.Player(this.el, this.options);\n    this.el = this.player.getIframe();\n  }\n  /**\n   * Player ready callback. Will play the video if it was intended to be played\n   * and will also call any pending callbacks.\n   */\n\n\n  onPlayerReady() {\n    this.ready = true; // Restoring the current time if saved\n\n    if (this.currentTime) {\n      this.player.seekTo(this.currentTime, true);\n      this.player.pauseVideo();\n      this.currentTime = null;\n    }\n\n    if (this.timeout && this.player.getPlayerState() !== 1) {\n      this.play();\n    }\n\n    if (this.onReadyCb) {\n      this.onReadyCb();\n      this.onReadyCb = null;\n    }\n  }\n  /**\n   * Plays the video.\n   */\n\n\n  play() {\n    if (this.ready) {\n      this.timeout = setTimeout(() => {\n        this.timeout = null;\n      }, 1000);\n\n      if (this.isMuted) {\n        this.player.mute();\n      } else {\n        this.player.unMute();\n      }\n\n      this.player.playVideo();\n    } else {\n      this.onReadyCb = this.play;\n    }\n  }\n  /**\n   * Pause playing the video if it's already playing.\n   */\n\n\n  pause() {\n    if (this.player && this.player.pauseVideo && this.player.getPlayerState() === 1) {\n      this.player.pauseVideo();\n    }\n  }\n  /**\n   * Parses the element to have the proper variables.\n   * @param {Element} element\n   * @return {Object} Player variables.\n   */\n\n\n  getPlayerVars(element) {\n    const vars = {\n      modestbranding: 1,\n      rel: 0,\n      origin: window.location.origin\n    };\n\n    if (this.slide.classList.contains('fullscreen')) {\n      // Disabling keyboard interaction for fullscreenvideos\n      vars.disablekb = 1;\n    }\n\n    if (typeof element.dataset.noControls !== 'undefined') {\n      vars.controls = 0;\n      vars.showinfo = 0;\n    }\n\n    if (typeof element.dataset.loop !== 'undefined') {\n      vars.loop = 1;\n      vars.playlist = element.dataset.youtubeId;\n    }\n\n    return vars;\n  }\n\n}\n/**\n * Video plugin.\n */\n\n\nclass youtube_YouTube {\n  /**\n   * Grid plugin that shows a grid on top of the WebSlides for easy prototyping.\n   * @param {WebSlides} wsInstance The WebSlides instance\n   */\n  constructor(wsInstance) {\n    /**\n     * @type {WebSlides}\n     * @private\n     */\n    this.ws_ = wsInstance;\n    this.videos = dom_DOM.toArray(this.ws_.el.querySelectorAll('[data-youtube]'));\n\n    if (this.videos.length) {\n      this.inject();\n    }\n  }\n  /**\n   * Once the YouTube API is ready this gets called so we can start the videos.\n   */\n\n\n  onYTReady() {\n    this.videos.forEach(video => {\n      const player = new youtube_Player(video);\n\n      if (typeof video.dataset.autoplay !== 'undefined') {\n        const {\n          i\n        } = slide_Slide.getSectionFromEl(player.el);\n        const slide = this.ws_.slides[i - 1];\n        slide.player = player;\n        slide.el.addEventListener(Events.ENABLE, youtube_YouTube.onSlideEvent);\n        slide.el.addEventListener(Events.DISABLE, youtube_YouTube.onSlideEvent);\n        slide.el.addEventListener(Events.ENTER, youtube_YouTube.onSlideEvent);\n        slide.el.addEventListener(Events.LEAVE, youtube_YouTube.onSlideEvent);\n\n        if (this.ws_.currentSlide_ === slide) {\n          youtube_YouTube.onSectionEnabled(slide);\n        }\n      }\n    });\n  }\n  /**\n   * Injects the YouTube iFrame API into the page.\n   */\n\n\n  inject() {\n    window.onYouTubeIframeAPIReady = this.onYTReady.bind(this);\n    const tag = document.createElement('script');\n    tag.src = `https://www.youtube.com/iframe_api`;\n    const firstScriptTag = document.getElementsByTagName('script')[0];\n    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\n  }\n  /**\n   * Reacts to any event on the slide.\n   * @param {CustomEvent} event\n   */\n\n\n  static onSlideEvent(event) {\n    const slide = event.detail.slide;\n\n    switch (event.type) {\n      case Events.ENABLE:\n        youtube_YouTube.onSectionEnabled(slide);\n        break;\n\n      case Events.DISABLE:\n        youtube_YouTube.onSectionDisabled(slide);\n        break;\n\n      case Events.LEAVE:\n        slide.player.destroy();\n        break;\n\n      case Events.ENTER:\n        slide.player.create();\n        break;\n    }\n  }\n  /**\n   * On Section enable hook. Will play the video.\n   * @param {Slide} slide\n   */\n\n\n  static onSectionEnabled(slide) {\n    if (slide.player.autoplay) {\n      slide.player.play();\n    }\n  }\n  /**\n   * On Section enable hook. Will pause the video.\n   * @param {Slide} slide\n   */\n\n\n  static onSectionDisabled(slide) {\n    slide.player.pause();\n  }\n\n}\n// CONCATENATED MODULE: /Users/wangyongqing01/www/git/nodeppt/packages/nodeppt-serve/node_modules/nodeppt-js/node_modules/webslides/src/js/utils/easing.js\n/**\n * Swing easing function.\n * @param {number} p The percentage of time that has passed.\n * @return {number}\n */\nfunction swing(p) {\n  return 0.5 - Math.cos(p * Math.PI) / 2;\n}\n\n/* harmony default export */ var easing = ({\n  swing\n});\n// CONCATENATED MODULE: /Users/wangyongqing01/www/git/nodeppt/packages/nodeppt-serve/node_modules/nodeppt-js/node_modules/webslides/src/js/utils/scroll-to.js\n\nlet SCROLLABLE_CONTAINER = document.getElementById('webslides');\n/**\n * Smoothly scrolls to a given Y position using Easing.Swing. It'll run a\n * callback upon finishing.\n * @param {number} y Offset of the page to scroll to.\n * @param {number} duration Duration of the animation. 500ms by default.\n * @param {function} cb Callback function to call upon completion.\n * @param {HTMLElement} container The HTML element where to scroll\n */\n\nfunction scrollTo(y, duration = 500, cb = () => {}, container = null) {\n  SCROLLABLE_CONTAINER = container ? container : document.getElementById('webslides');\n  const delta = y - SCROLLABLE_CONTAINER.scrollTop;\n  const startLocation = SCROLLABLE_CONTAINER.scrollTop;\n  const increment = 16;\n\n  if (!duration) {\n    SCROLLABLE_CONTAINER.scrollTop = y;\n    cb();\n    return;\n  }\n\n  const animateScroll = elapsedTime => {\n    elapsedTime += increment;\n    const percent = Math.min(1, elapsedTime / duration);\n    const easingP = easing.swing(percent, elapsedTime * percent, y, delta, duration);\n    SCROLLABLE_CONTAINER.scrollTop = Math.floor(startLocation + easingP * delta);\n\n    if (elapsedTime < duration) {\n      setTimeout(() => animateScroll(elapsedTime), increment);\n    } else {\n      cb();\n    }\n  };\n\n  animateScroll(0);\n}\n// CONCATENATED MODULE: /Users/wangyongqing01/www/git/nodeppt/packages/nodeppt-serve/node_modules/nodeppt-js/node_modules/webslides/src/js/plugins/zoom.js\n\n\n\n\nconst zoom_CLASSES = {\n  ZOOM: 'grid',\n  DIV: 'column',\n  WRAP: 'wrap-zoom',\n  WRAP_CONTAINER: 'wrap',\n  CURRENT: 'current',\n  SLIDE: 'slide',\n  ZOOM_ENABLED: 'ws-ready-zoom'\n};\nconst ID = 'webslides-zoomed';\n/**\n * Zoom plugin.\n */\n\nclass zoom_Zoom {\n  /**\n   * @param {WebSlides} wsInstance The WebSlides instance\n   * @constructor\n   */\n  constructor(wsInstance) {\n    /**\n     * @type {WebSlides}\n     * @private\n     */\n    this.ws_ = wsInstance;\n    /**\n     * @type {WebSlides}\n     * @private\n     */\n\n    this.zws_ = {};\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    this.isZoomed_ = false;\n    this.preBuildZoom_();\n    document.body.addEventListener('keydown', this.onKeyDown.bind(this));\n  }\n  /**\n   * On key down handler. Will decide if Zoom in or out\n   * @param {Event} event Key down event.\n   */\n\n\n  onKeyDown(event) {\n    if (!this.isZoomed_ && keys.MINUS.some(key => key === event.which)) {\n      this.zoomIn();\n    } else if (this.isZoomed_ && (keys.PLUS.some(key => key === event.which) || event.which === keys.ESCAPE)) {\n      this.zoomOut();\n    }\n  }\n  /**\n   * Prepare zoom structure, scales the slides and uses a grid layout\n   * to show them.\n   */\n\n\n  preBuildZoom_() {\n    // Clone #webslides element\n    this.zws_.el = this.ws_.el.cloneNode();\n    this.zws_.el.id = ID;\n    this.zws_.wrap = dom_DOM.createNode('div');\n    this.zws_.wrap.className = zoom_CLASSES.WRAP_CONTAINER;\n    this.zws_.el.appendChild(this.zws_.wrap);\n    this.zws_.grid = dom_DOM.createNode('div');\n    this.zws_.grid.className = zoom_CLASSES.ZOOM;\n    this.zws_.wrap.appendChild(this.zws_.grid);\n    this.zws_.el.addEventListener('click', () => this.toggleZoom()); // Clone the slides\n\n    this.zws_.slides = [].map.call(this.ws_.slides, (slide, i) => {\n      const s_ = slide.el.cloneNode(true);\n      this.zws_.grid.appendChild(s_);\n      return new slide_Slide(s_, i);\n    });\n    this.disable();\n    dom_DOM.after(this.zws_.el, this.ws_.el); // Creates the container for each slide\n\n    this.zws_.slides.forEach(elem => this.createSlideBlock_(elem));\n  }\n  /**\n   * Creates a block structure around the slide.\n   * @param {Element} elem slide element.\n   */\n\n\n  createSlideBlock_(elem) {\n    // Wraps the slide around a container\n    const wrap = dom_DOM.wrap(elem.el, 'div');\n    wrap.className = zoom_CLASSES.WRAP;\n    wrap.setAttribute('id', `zoomed-${elem.el.getAttribute('id')}`); // Slide container, need due to flexbox styles\n\n    const div = dom_DOM.wrap(wrap, 'div');\n    div.className = zoom_CLASSES.DIV; // Adding some layer for controlling click events\n\n    const divLayer = dom_DOM.createNode('div');\n    divLayer.className = 'zoom-layer';\n    divLayer.addEventListener('click', e => {\n      e.stopPropagation();\n      this.zoomOut();\n      this.ws_.goToSlide(elem.i);\n    });\n    wrap.appendChild(divLayer); // Slide number\n\n    const slideNumber = dom_DOM.createNode('p', '', `${elem.i + 1}`);\n    slideNumber.className = 'text-slide-number';\n    div.appendChild(slideNumber);\n  }\n  /**\n   * Toggles zoom.\n   */\n\n\n  toggleZoom() {\n    if (this.isZoomed_) {\n      this.zoomOut();\n    } else {\n      this.zoomIn();\n    }\n  }\n  /**\n   * Zoom In the slider, scales the slides and uses a grid layout to show them.\n   */\n\n\n  zoomIn() {\n    if (!this.ws_.options.showIndex) return;\n    this.enable();\n    const currentId = this.ws_.currentSlide_.el.id;\n    const zoomedCurrent = this.zws_.el.querySelector(`.${zoom_CLASSES.WRAP}.${zoom_CLASSES.CURRENT}`);\n\n    if (zoomedCurrent) {\n      zoomedCurrent.classList.remove(zoom_CLASSES.CURRENT);\n    }\n\n    const actualCurrent = this.zws_.el.querySelector(`#zoomed-${currentId}`);\n    actualCurrent.classList.add(zoom_CLASSES.CURRENT);\n    this.isZoomed_ = true;\n    document.documentElement.classList.add(zoom_CLASSES.ZOOM_ENABLED);\n    setTimeout(() => {\n      this.ws_.disable();\n      this.zws_.el.classList.add('in');\n      const wrapCSS = window.getComputedStyle(this.zws_.grid);\n      const scrollingElement = document.body;\n      scrollTo(actualCurrent.parentNode.offsetTop + dom_DOM.parseSize(wrapCSS.paddingTop), 50, () => {}, scrollingElement);\n    }, 50);\n  }\n  /**\n   * Zoom Out the slider, remove scale from the slides.\n   */\n\n\n  zoomOut() {\n    if (!this.ws_.options.showIndex) return;\n    this.zws_.el.classList.remove('in');\n    setTimeout(() => {\n      this.ws_.enable();\n      this.disable();\n      this.isZoomed_ = false;\n      document.documentElement.classList.remove(zoom_CLASSES.ZOOM_ENABLED);\n    }, 400);\n  }\n  /**\n   * Hides the zoom container\n   */\n\n\n  disable() {\n    this.zws_.el.classList.add('disabled');\n  }\n  /**\n   * Shows the zoom container\n   */\n\n\n  enable() {\n    this.zws_.el.classList.remove('disabled');\n  }\n\n}\n// CONCATENATED MODULE: /Users/wangyongqing01/www/git/nodeppt/packages/nodeppt-serve/node_modules/nodeppt-js/node_modules/webslides/src/js/plugins/plugins.js\n\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ var plugins = ({\n  AutoSlide: autoslide_AutoSlide,\n  ClickNav: ClickNav,\n  Grid: grid_Grid,\n  Hash: Hash,\n  Keyboard: keyboard_Keyboard,\n  Navigation: navigation_Navigation,\n  Scroll: scroll_Scroll,\n  Touch: touch_Touch,\n  Video: video_Video,\n  YouTube: youtube_YouTube,\n  Zoom: zoom_Zoom\n});\n// CONCATENATED MODULE: /Users/wangyongqing01/www/git/nodeppt/packages/nodeppt-serve/node_modules/nodeppt-js/node_modules/webslides/src/js/modules/webslides.js\n\n\n\n\nconst webslides_CLASSES = {\n  VERTICAL: 'vertical',\n  READY: 'ws-ready',\n  DISABLED: 'disabled'\n}; // Default plugins\n\nconst PLUGINS = {\n  'autoslide': plugins.AutoSlide,\n  'clickNav': plugins.ClickNav,\n  'grid': plugins.Grid,\n  'hash': plugins.Hash,\n  'keyboard': plugins.Keyboard,\n  'nav': plugins.Navigation,\n  'scroll': plugins.Scroll,\n  'touch': plugins.Touch,\n  'video': plugins.Video,\n  'youtube': plugins.YouTube,\n  'zoom': plugins.Zoom\n};\n/**\n * WebSlides module.\n */\n\nclass webslides_WebSlides {\n  /**\n   * Options for WebSlides\n   * @param {number|boolean} autoslide If a number is provided, it will allow\n   * autosliding by said amount of milliseconds.\n   * @param {boolean} changeOnClick If true, it will allow\n   * clicking on any place to change the slide.\n   * @param {boolean} loop Whether to go to first slide from last one or not.\n   * @param {number} minWheelDelta Controls the amount of needed scroll to\n   * trigger navigation.\n   * @param {boolean} navigateOnScroll Whether scroll can trigger navigation or\n   * not.\n   * @param {number} scrollWait Controls the amount of time to wait till\n   * navigation can occur again with scroll.\n   * @param {number} slideOffset Controls the amount of needed touch delta to\n   * trigger navigation.\n   * @param {boolean} showIndex Controls if the index can be shown.\n   */\n  constructor({\n    autoslide = false,\n    changeOnClick = false,\n    loop = true,\n    minWheelDelta = 40,\n    navigateOnScroll = true,\n    scrollWait = 450,\n    slideOffset = 50,\n    showIndex = true\n  } = {}) {\n    /**\n     * WebSlide element.\n     * @type {Element}\n     */\n    this.el = document.getElementById('webslides');\n\n    if (!this.el) {\n      throw new Error('Couldn\\'t find the webslides container!');\n    }\n    /**\n     * Moving flag.\n     * @type {boolean}\n     */\n\n\n    this.isMoving = false;\n    /**\n     * Slide's array.\n     * @type {?Array<Slide>}\n     */\n\n    this.slides = null;\n    /**\n     * Current slide's index.\n     * @type {number}\n     * @private\n     */\n\n    this.currentSlideI_ = -1;\n    /**\n     * Current slide reference.\n     * @type {?Slide}\n     * @private\n     */\n\n    this.currentSlide_ = null;\n    /**\n     * Max slide index.\n     * @type {number}\n     * @private\n     */\n\n    this.maxSlide_ = 0;\n    /**\n     * Whether the layout is going to be vertical or horizontal.\n     * @type {boolean}\n     */\n\n    this.isVertical = this.el.classList.contains(webslides_CLASSES.VERTICAL);\n    /**\n     * Plugin's dictionary.\n     * @type {Object}\n     */\n\n    this.plugins = {};\n    /**\n     * Options dictionary.\n     * @type {Object}\n     */\n\n    this.options = {\n      autoslide,\n      changeOnClick,\n      loop,\n      minWheelDelta,\n      navigateOnScroll,\n      scrollWait,\n      slideOffset,\n      showIndex\n    };\n    /**\n     * Initialisation flag.\n     * @type {boolean}\n     */\n\n    this.initialised = false; // Bootstrapping\n\n    this.removeChildren_();\n    this.grabSlides_();\n    this.createPlugins_();\n    this.initSlides_(); // Finished\n\n    this.onInit_();\n  }\n  /**\n   * Removes all children elements inside of the main container that are not\n   * eligible to be a Slide Element.\n   * @private\n   */\n\n\n  removeChildren_() {\n    const nodes = this.el.childNodes;\n    let i = nodes.length;\n\n    while (i--) {\n      const node = nodes[i];\n\n      if (!slide_Slide.isCandidate(node)) {\n        this.el.removeChild(node);\n      }\n    }\n  }\n  /**\n   * Creates all the registered plugins and store the instances inside of the\n   * the webslide instance.\n   * @private\n   */\n\n\n  createPlugins_() {\n    Object.keys(PLUGINS).forEach(pluginName => {\n      const PluginCto = PLUGINS[pluginName];\n      this.plugins[pluginName] = new PluginCto(this);\n    });\n  }\n  /**\n   * Called once the WebSlide instance has finished initialising.\n   * @private\n   * @fires WebSlide#ws:init\n   */\n\n\n  onInit_() {\n    this.initialised = true;\n    dom_DOM.fireEvent(this.el, 'ws:init');\n    document.documentElement.classList.add(webslides_CLASSES.READY);\n  }\n  /**\n   * Grabs the slides from the DOM and creates all the Slides modules.\n   * @private\n   */\n\n\n  grabSlides_() {\n    this.slides = dom_DOM.toArray(this.el.childNodes).map((slide, i) => new slide_Slide(slide, i));\n    this.maxSlide_ = this.slides.length;\n  }\n  /**\n   * Goes to a given slide.\n   * @param {!number} slideI The slide index.\n   * @param {?boolean=} forward Whether we're forcing moving forward/backwards.\n   * This parameter is used only from the goNext, goPrev functions to adjust the\n   * scroll animations.\n   */\n\n\n  goToSlide(slideI, forward = null) {\n    if (this.isValidIndexSlide_(slideI) && !this.isMoving && this.currentSlideI_ !== slideI) {\n      this.isMoving = true;\n      let isMovingForward = false;\n\n      if (forward !== null) {\n        isMovingForward = forward;\n      } else {\n        if (this.currentSlideI_ >= 0) {\n          isMovingForward = slideI > this.currentSlideI_;\n        }\n      }\n\n      const nextSlide = this.slides[slideI];\n\n      if (this.currentSlide_ !== null && this.isVertical && (!this.plugins.touch || !this.plugins.touch.isEnabled)) {\n        this.scrollTransitionToSlide_(isMovingForward, nextSlide, this.onSlideChange_);\n      } else {\n        this.transitionToSlide_(isMovingForward, nextSlide, this.onSlideChange_);\n      }\n    }\n  }\n  /**\n   * Transitions to a slide, doing the scroll animation.\n   * @param {boolean} isMovingForward Whether we're going forward or backwards.\n   * @param {Slide} nextSlide Next slide.\n   * @param {Function} callback Callback to be called upon finishing. This is an\n   * async function so it'll happen once the scroll animation finishes.\n   * @private\n   * @see scrollTo\n   */\n\n\n  scrollTransitionToSlide_(isMovingForward, nextSlide, callback) {\n    this.el.style.overflow = 'hidden';\n\n    if (!isMovingForward) {\n      nextSlide.moveBeforeFirst();\n      nextSlide.show();\n      scrollTo(this.currentSlide_.el.offsetTop, 0);\n    } else {\n      nextSlide.show();\n    }\n\n    scrollTo(nextSlide.el.offsetTop, 500, () => {\n      this.currentSlide_.hide();\n\n      if (isMovingForward) {\n        this.currentSlide_.moveAfterLast();\n      }\n\n      this.el.style.overflow = 'auto';\n      setTimeout(() => {\n        callback.call(this, nextSlide);\n      }, 150);\n    });\n  }\n  /**\n   * Transitions to a slide, without doing the scroll animation. If the page is\n   * already initialised and on mobile device, it will do a slide animation.\n   * @param {boolean} isMovingForward Whether we're going forward or backwards.\n   * @param {Slide} nextSlide Next slide.\n   * @param {Function} callback Callback to be called upon finishing. This is a\n   * sync function so it'll happen on run time.\n   * @private\n   */\n\n\n  transitionToSlide_(isMovingForward, nextSlide, callback) {\n    scrollTo(0, 0);\n    let className = 'slideInRight';\n\n    if (!isMovingForward) {\n      nextSlide.moveBeforeFirst();\n      className = 'slideInLeft';\n    }\n\n    if (this.currentSlide_) {\n      if (isMovingForward) {\n        this.currentSlide_.moveAfterLast();\n      }\n\n      this.currentSlide_.hide();\n    }\n\n    nextSlide.show();\n\n    if (this.initialised && this.plugins.touch && this.plugins.touch.isEnabled) {\n      dom_DOM.once(nextSlide.el, dom_DOM.getAnimationEvent(), () => {\n        nextSlide.el.classList.remove(className);\n        callback.call(this, nextSlide);\n      });\n      nextSlide.el.classList.add(className);\n    } else {\n      callback.call(this, nextSlide);\n    }\n  }\n  /**\n   * Whenever a slide is changed, this function gets called. It updates the\n   * references to the current slide, disables the moving flag and fires\n   * a custom event.\n   * @param {Slide} slide The slide we're transitioning to.\n   * @fires WebSlide#ws:slide-change\n   * @private\n   */\n\n\n  onSlideChange_(slide) {\n    if (this.currentSlide_) {\n      this.currentSlide_.disable();\n    }\n\n    this.currentSlide_ = slide;\n    this.currentSlideI_ = slide.i;\n    this.currentSlide_.enable();\n    this.isMoving = false;\n    dom_DOM.fireEvent(this.el, 'ws:slide-change', {\n      slides: this.maxSlide_,\n      currentSlide0: this.currentSlideI_,\n      currentSlide: this.currentSlideI_ + 1\n    });\n  }\n  /**\n   * Goes to the next slide.\n   */\n\n\n  goNext() {\n    let nextIndex = this.currentSlideI_ + 1;\n\n    if (nextIndex >= this.maxSlide_) {\n      if (!this.options.loop) {\n        return;\n      }\n\n      nextIndex = 0;\n    }\n\n    this.goToSlide(nextIndex, true);\n  }\n  /**\n   * Goes to the previous slide.\n   */\n\n\n  goPrev() {\n    let prevIndex = this.currentSlideI_ - 1;\n\n    if (prevIndex < 0) {\n      if (!this.options.loop) {\n        return;\n      }\n\n      prevIndex = this.maxSlide_ - 1;\n    }\n\n    this.goToSlide(prevIndex, false);\n  }\n  /**\n   * Check if the given number is a valid index to go to.\n   * @param {number} i The index to check.\n   * @return {boolean} Whether you can move to that slide or not.\n   * @private\n   */\n\n\n  isValidIndexSlide_(i) {\n    return typeof i === 'number' && i >= 0 && i < this.maxSlide_;\n  }\n  /**\n   * Init the shown slide on load. It'll fetch it from the Hash if present\n   * and, otherwise, it'll default to the first one.\n   * @private\n   * @see Hash.getSlideNumber\n   */\n\n\n  initSlides_() {\n    let slideNumber = this.plugins.hash.constructor.getSlideNumber(); // Not valid\n\n    if (slideNumber === null || slideNumber >= this.maxSlide_) {\n      slideNumber = 0;\n    } // Keeping the order\n\n\n    if (slideNumber !== 0) {\n      let i = 0;\n\n      while (i < slideNumber) {\n        this.slides[i].moveAfterLast();\n        i++;\n      }\n    }\n\n    this.goToSlide(slideNumber);\n  }\n  /**\n   * Toggles zoom\n   */\n\n\n  toggleZoom() {\n    if (this.options.showIndex) {\n      this.plugins.zoom.toggleZoom();\n    }\n  }\n  /**\n   * Disables the webslides element adding a class \"disabled\"\n   */\n\n\n  disable() {\n    this.el.classList.add(webslides_CLASSES.DISABLED);\n\n    if (this.plugins.autoslide && this.plugins.autoslide.time !== false) {\n      this.plugins.autoslide.stop();\n    }\n  }\n  /**\n   * Enables the webslides element removing a class \"disabled\"\n   */\n\n\n  enable() {\n    this.el.classList.remove(webslides_CLASSES.DISABLED);\n\n    if (this.plugins.autoslide && this.plugins.autoslide.time !== false) {\n      this.plugins.autoslide.play();\n    }\n  }\n  /**\n   * Checks if it is disabled\n   * @return {boolean}\n   */\n\n\n  isDisabled() {\n    return this.el.classList.contains(webslides_CLASSES.DISABLED);\n  }\n  /**\n   * Puts the browser into fullscreen\n   */\n\n\n  fullscreen() {\n    const el = document.documentElement;\n    const isFullscreen = document.fullscreen || document.webkitIsFullScreen || document.mozFullScreen || document.msFullScreenElement;\n\n    if (!isFullscreen) {\n      /* istanbul ignore next hard to test prefixes */\n      const requestFullscreen = el.requestFullscreen || el.webkitRequestFullScreen || el.mozRequestFullScreen || el.msRequestFullscreen;\n      requestFullscreen.call(el);\n    } else {\n      /* istanbul ignore next hard to test prefixes */\n      const cancelFullscreen = document.exitFullScreen || document.webkitCancelFullScreen || document.mozCancelFullScreen || document.msExitFullscreen;\n      cancelFullscreen.call(document);\n    }\n  }\n  /**\n   * Registers a plugin to be loaded when the instance is created. It allows\n   * (on purpose) to replace default plugins.\n   * @param {!string} key They key under which it'll be stored inside of the\n   * instance, inside the plugins dict.\n   * @param {!Function} cto Plugin constructor.\n   */\n\n\n  static registerPlugin(key, cto) {\n    PLUGINS[key] = cto;\n  }\n\n}\n// EXTERNAL MODULE: /Users/wangyongqing01/www/git/nodeppt/packages/nodeppt-serve/node_modules/nodeppt-js/assets/scss/full.scss\nvar full = __webpack_require__(1);\n\n// EXTERNAL MODULE: /Users/wangyongqing01/www/git/nodeppt/packages/nodeppt-serve/node_modules/nodeppt-js/assets/scss/index.scss\nvar scss = __webpack_require__(2);\n\n// CONCATENATED MODULE: /Users/wangyongqing01/www/git/nodeppt/packages/nodeppt-serve/node_modules/nodeppt-js/index.js\n\n\n\n/* harmony default export */ var nodeppt_js = (webslides_WebSlides);\n// CONCATENATED MODULE: /Users/wangyongqing01/www/git/nodeppt/packages/nodeppt-serve/template/main.js\n/**\n * 页面的 main.js\n */\n\nwindow.WebSlide = nodeppt_js;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvd2FuZ3lvbmdxaW5nMDEvd3d3L2dpdC9ub2RlcHB0L3BhY2thZ2VzL25vZGVwcHQtc2VydmUvbm9kZV9tb2R1bGVzL25vZGVwcHQtanMvbm9kZV9tb2R1bGVzL3dlYnNsaWRlcy9zcmMvanMvdXRpbHMvY3VzdG9tLWV2ZW50LmpzPzk5NzkiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy93YW5neW9uZ3FpbmcwMS93d3cvZ2l0L25vZGVwcHQvcGFja2FnZXMvbm9kZXBwdC1zZXJ2ZS9ub2RlX21vZHVsZXMvbm9kZXBwdC1qcy9ub2RlX21vZHVsZXMvd2Vic2xpZGVzL3NyYy9qcy91dGlscy9kb20uanM/NzUzMiIsIndlYnBhY2s6Ly8vL1VzZXJzL3dhbmd5b25ncWluZzAxL3d3dy9naXQvbm9kZXBwdC9wYWNrYWdlcy9ub2RlcHB0LXNlcnZlL25vZGVfbW9kdWxlcy9ub2RlcHB0LWpzL25vZGVfbW9kdWxlcy93ZWJzbGlkZXMvc3JjL2pzL3BsdWdpbnMvYXV0b3NsaWRlLmpzP2M0YmMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy93YW5neW9uZ3FpbmcwMS93d3cvZ2l0L25vZGVwcHQvcGFja2FnZXMvbm9kZXBwdC1zZXJ2ZS9ub2RlX21vZHVsZXMvbm9kZXBwdC1qcy9ub2RlX21vZHVsZXMvd2Vic2xpZGVzL3NyYy9qcy9wbHVnaW5zL2NsaWNrLW5hdi5qcz80YjQ5Iiwid2VicGFjazovLy8vVXNlcnMvd2FuZ3lvbmdxaW5nMDEvd3d3L2dpdC9ub2RlcHB0L3BhY2thZ2VzL25vZGVwcHQtc2VydmUvbm9kZV9tb2R1bGVzL25vZGVwcHQtanMvbm9kZV9tb2R1bGVzL3dlYnNsaWRlcy9zcmMvanMvdXRpbHMva2V5cy5qcz8wNDYwIiwid2VicGFjazovLy8vVXNlcnMvd2FuZ3lvbmdxaW5nMDEvd3d3L2dpdC9ub2RlcHB0L3BhY2thZ2VzL25vZGVwcHQtc2VydmUvbm9kZV9tb2R1bGVzL25vZGVwcHQtanMvbm9kZV9tb2R1bGVzL3dlYnNsaWRlcy9zcmMvanMvcGx1Z2lucy9ncmlkLmpzP2JmMzgiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy93YW5neW9uZ3FpbmcwMS93d3cvZ2l0L25vZGVwcHQvcGFja2FnZXMvbm9kZXBwdC1zZXJ2ZS9ub2RlX21vZHVsZXMvbm9kZXBwdC1qcy9ub2RlX21vZHVsZXMvd2Vic2xpZGVzL3NyYy9qcy9wbHVnaW5zL2hhc2guanM/ZGM4OSIsIndlYnBhY2s6Ly8vL1VzZXJzL3dhbmd5b25ncWluZzAxL3d3dy9naXQvbm9kZXBwdC9wYWNrYWdlcy9ub2RlcHB0LXNlcnZlL25vZGVfbW9kdWxlcy9ub2RlcHB0LWpzL25vZGVfbW9kdWxlcy93ZWJzbGlkZXMvc3JjL2pzL3BsdWdpbnMva2V5Ym9hcmQuanM/NWMwZiIsIndlYnBhY2s6Ly8vL1VzZXJzL3dhbmd5b25ncWluZzAxL3d3dy9naXQvbm9kZXBwdC9wYWNrYWdlcy9ub2RlcHB0LXNlcnZlL25vZGVfbW9kdWxlcy9ub2RlcHB0LWpzL25vZGVfbW9kdWxlcy93ZWJzbGlkZXMvc3JjL2pzL3BsdWdpbnMvbmF2aWdhdGlvbi5qcz82ZDRiIiwid2VicGFjazovLy8vVXNlcnMvd2FuZ3lvbmdxaW5nMDEvd3d3L2dpdC9ub2RlcHB0L3BhY2thZ2VzL25vZGVwcHQtc2VydmUvbm9kZV9tb2R1bGVzL25vZGVwcHQtanMvbm9kZV9tb2R1bGVzL3dlYnNsaWRlcy9zcmMvanMvdXRpbHMvbW9iaWxlLWRldGVjdG9yLmpzPzg5YTEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy93YW5neW9uZ3FpbmcwMS93d3cvZ2l0L25vZGVwcHQvcGFja2FnZXMvbm9kZXBwdC1zZXJ2ZS9ub2RlX21vZHVsZXMvbm9kZXBwdC1qcy9ub2RlX21vZHVsZXMvd2Vic2xpZGVzL3NyYy9qcy9wbHVnaW5zL3Njcm9sbC5qcz9kOGIzIiwid2VicGFjazovLy8vVXNlcnMvd2FuZ3lvbmdxaW5nMDEvd3d3L2dpdC9ub2RlcHB0L3BhY2thZ2VzL25vZGVwcHQtc2VydmUvbm9kZV9tb2R1bGVzL25vZGVwcHQtanMvbm9kZV9tb2R1bGVzL3dlYnNsaWRlcy9zcmMvanMvcGx1Z2lucy90b3VjaC5qcz9jODNiIiwid2VicGFjazovLy8vVXNlcnMvd2FuZ3lvbmdxaW5nMDEvd3d3L2dpdC9ub2RlcHB0L3BhY2thZ2VzL25vZGVwcHQtc2VydmUvbm9kZV9tb2R1bGVzL25vZGVwcHQtanMvbm9kZV9tb2R1bGVzL3dlYnNsaWRlcy9zcmMvanMvbW9kdWxlcy9zbGlkZS5qcz83OThjIiwid2VicGFjazovLy8vVXNlcnMvd2FuZ3lvbmdxaW5nMDEvd3d3L2dpdC9ub2RlcHB0L3BhY2thZ2VzL25vZGVwcHQtc2VydmUvbm9kZV9tb2R1bGVzL25vZGVwcHQtanMvbm9kZV9tb2R1bGVzL3dlYnNsaWRlcy9zcmMvanMvcGx1Z2lucy92aWRlby5qcz8wZGIzIiwid2VicGFjazovLy8vVXNlcnMvd2FuZ3lvbmdxaW5nMDEvd3d3L2dpdC9ub2RlcHB0L3BhY2thZ2VzL25vZGVwcHQtc2VydmUvbm9kZV9tb2R1bGVzL25vZGVwcHQtanMvbm9kZV9tb2R1bGVzL3dlYnNsaWRlcy9zcmMvanMvcGx1Z2lucy95b3V0dWJlLmpzP2JmOGUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy93YW5neW9uZ3FpbmcwMS93d3cvZ2l0L25vZGVwcHQvcGFja2FnZXMvbm9kZXBwdC1zZXJ2ZS9ub2RlX21vZHVsZXMvbm9kZXBwdC1qcy9ub2RlX21vZHVsZXMvd2Vic2xpZGVzL3NyYy9qcy91dGlscy9lYXNpbmcuanM/NmE1NSIsIndlYnBhY2s6Ly8vL1VzZXJzL3dhbmd5b25ncWluZzAxL3d3dy9naXQvbm9kZXBwdC9wYWNrYWdlcy9ub2RlcHB0LXNlcnZlL25vZGVfbW9kdWxlcy9ub2RlcHB0LWpzL25vZGVfbW9kdWxlcy93ZWJzbGlkZXMvc3JjL2pzL3V0aWxzL3Njcm9sbC10by5qcz9iMjFhIiwid2VicGFjazovLy8vVXNlcnMvd2FuZ3lvbmdxaW5nMDEvd3d3L2dpdC9ub2RlcHB0L3BhY2thZ2VzL25vZGVwcHQtc2VydmUvbm9kZV9tb2R1bGVzL25vZGVwcHQtanMvbm9kZV9tb2R1bGVzL3dlYnNsaWRlcy9zcmMvanMvcGx1Z2lucy96b29tLmpzP2FiMmEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy93YW5neW9uZ3FpbmcwMS93d3cvZ2l0L25vZGVwcHQvcGFja2FnZXMvbm9kZXBwdC1zZXJ2ZS9ub2RlX21vZHVsZXMvbm9kZXBwdC1qcy9ub2RlX21vZHVsZXMvd2Vic2xpZGVzL3NyYy9qcy9wbHVnaW5zL3BsdWdpbnMuanM/MDNkNyIsIndlYnBhY2s6Ly8vL1VzZXJzL3dhbmd5b25ncWluZzAxL3d3dy9naXQvbm9kZXBwdC9wYWNrYWdlcy9ub2RlcHB0LXNlcnZlL25vZGVfbW9kdWxlcy9ub2RlcHB0LWpzL25vZGVfbW9kdWxlcy93ZWJzbGlkZXMvc3JjL2pzL21vZHVsZXMvd2Vic2xpZGVzLmpzP2FjNjciLCJ3ZWJwYWNrOi8vLy9Vc2Vycy93YW5neW9uZ3FpbmcwMS93d3cvZ2l0L25vZGVwcHQvcGFja2FnZXMvbm9kZXBwdC1zZXJ2ZS9ub2RlX21vZHVsZXMvbm9kZXBwdC1qcy9pbmRleC5qcz9mM2FjIiwid2VicGFjazovLy8vVXNlcnMvd2FuZ3lvbmdxaW5nMDEvd3d3L2dpdC9ub2RlcHB0L3BhY2thZ2VzL25vZGVwcHQtc2VydmUvdGVtcGxhdGUvbWFpbi5qcz84Yjk1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE5hdGl2ZUN1c3RvbUV2ZW50ID0gd2luZG93LkN1c3RvbUV2ZW50O1xuXG4vKipcbiAqIENoZWNrIGZvciB0aGUgdXNhZ2Ugb2YgbmF0aXZlIHN1cHBvcnQgZm9yIEN1c3RvbUV2ZW50cyB3aGljaCBpcyBsYWNraW5nXG4gKiBjb21wbGV0ZWx5IG9uIElFLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBpdCBjYW4gYmUgdXNlZCBvciBub3QuXG4gKi9cbmZ1bmN0aW9uIGNhbkl1c2VOYXRpdmVDdXN0b20oKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcCA9IG5ldyBOYXRpdmVDdXN0b21FdmVudCgndCcsIHtcbiAgICAgIGRldGFpbDoge1xuICAgICAgICBhOiAnYidcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gJ3QnID09PSBwLnR5cGUgJiYgJ2InID09PSBwLmRldGFpbC5hO1xuICB9IGNhdGNoIChlKSB7IH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogaGFyZCB0byByZXByb2R1Y2Ugb24gdGVzdCBlbnZpcm9ubWVudCAgKi9cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIExvdXN5IHBvbHlmaWxsIGZvciB0aGUgQ3VzdG9tIEV2ZW50IGNvbnN0cnVjdG9yIGZvciBJRS5cbiAqIEBwYXJhbSB7IXN0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQuXG4gKiBAcGFyYW0gez9PYmplY3R9IHBhcmFtcyBBZGRpdGlvbmFsIGluZm9ybWF0aW9uIGZvciB0aGUgZXZlbnQuXG4gKiBAcmV0dXJuIHtFdmVudH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogaGFyZCB0byByZXByb2R1Y2Ugb24gdGVzdCBlbnZpcm9ubWVudCAgKi9cbmNvbnN0IElFQ3VzdG9tRXZlbnQgPSBmdW5jdGlvbiBDdXN0b21FdmVudCh0eXBlLCBwYXJhbXMpIHtcbiAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuXG4gIGlmIChwYXJhbXMpIHtcbiAgICBlLmluaXRDdXN0b21FdmVudCh0eXBlLCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICB9IGVsc2Uge1xuICAgIGUuaW5pdEN1c3RvbUV2ZW50KHR5cGUsIGZhbHNlLCBmYWxzZSwgdW5kZWZpbmVkKTtcbiAgfVxuXG4gIHJldHVybiBlO1xufTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGhhcmQgdG8gcmVwcm9kdWNlIG9uIHRlc3QgZW52aXJvbm1lbnQgICovXG5jb25zdCBXU0N1c3RvbUV2ZW50ID0gY2FuSXVzZU5hdGl2ZUN1c3RvbSgpID8gTmF0aXZlQ3VzdG9tRXZlbnQgOiBJRUN1c3RvbUV2ZW50O1xuXG5leHBvcnQgZGVmYXVsdCBXU0N1c3RvbUV2ZW50O1xuIiwiaW1wb3J0IFdTQ3VzdG9tRXZlbnQgZnJvbSAnLi9jdXN0b20tZXZlbnQnO1xuXG5sZXQgdHJhbnNpdGlvbkV2ZW50ID0gJyc7XG5sZXQgYW5pbWF0aW9uRXZlbnQgPSAnJztcblxuLyoqXG4gKiBTdGF0aWMgY2xhc3MgZm9yIERPTSBoZWxwZXIuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERPTSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbm9kZSB3aXRoIG9wdGlvbmFsIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIG5hbWUgb2YgdGhlIHRhZyBvZiB0aGUgbmVlZGVkIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgZGVzaXJlZCBpZCBmb3IgdGhlIGVsZW1lbnQuIEl0IGRlZmF1bHRzIHRvIGFuXG4gICAqIGVtcHR5IHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIGRlc2lyZWQgdGV4dCB0byBnbyBpbnNpZGUgb2YgdGhlIGVsZW1lbnQuIEl0XG4gICAqIGRlZmF1bHRzIHRvIGFuIGVtcHR5IHN0cmluZy5cbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVOb2RlKHRhZywgaWQgPSAnJywgdGV4dCA9ICcnKSB7XG4gICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBpZiAoaWQpIHtcbiAgICAgIG5vZGUuaWQgPSBpZDtcbiAgICB9XG5cbiAgICBpZiAodGV4dCkge1xuICAgICAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvKipcbiAgICogTGlzdGVucyBmb3IgYW4gZXZlbnQgb25jZS5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBFbGVtZW50IHRvIGxpc3RlbiB0by5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IEV2ZW50IFR5cGUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb25jZSB0aGUgZXZlbnQgZmlyZXMuXG4gICAqL1xuICBzdGF0aWMgb25jZShlbCwgZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY2IgPSBlID0+IHtcbiAgICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgY2IpO1xuICAgICAgICBjYWxsYmFjayhlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2IsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwcmVmaXhlZCB0cmFuc2l0aW9uZW5kIGV2ZW50LlxuICAgKiBAcGFyYW0gez9FbGVtZW50fSBvcHRFbCBFbGVtZW50IHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXRUcmFuc2l0aW9uRXZlbnQob3B0RWwpIHtcbiAgICBpZiAodHJhbnNpdGlvbkV2ZW50ICYmICFvcHRFbCkge1xuICAgICAgcmV0dXJuIHRyYW5zaXRpb25FdmVudDtcbiAgICB9XG5cbiAgICB0cmFuc2l0aW9uRXZlbnQgPSAnJztcblxuICAgIGNvbnN0IGVsID0gb3B0RWwgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnd3MnKTtcbiAgICBjb25zdCB0cmFuc2l0aW9ucyA9IHtcbiAgICAgICd0cmFuc2l0aW9uJzogJ3RyYW5zaXRpb25lbmQnLFxuICAgICAgJ09UcmFuc2l0aW9uJzogJ29UcmFuc2l0aW9uRW5kJyxcbiAgICAgICdNb3pUcmFuc2l0aW9uJzogJ3RyYW5zaXRpb25lbmQnLFxuICAgICAgJ1dlYmtpdFRyYW5zaXRpb24nOiAnd2Via2l0VHJhbnNpdGlvbkVuZCdcbiAgICB9O1xuICAgIGNvbnN0IHRyYW5zaXRpb25OYW1lcyA9IE9iamVjdC5rZXlzKHRyYW5zaXRpb25zKTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSB0cmFuc2l0aW9uTmFtZXMubGVuZ3RoO1xuICAgICAgICAgIGkgPCBsZW5ndGggJiYgIXRyYW5zaXRpb25FdmVudDsgaSsrKSB7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uTmFtZSA9IHRyYW5zaXRpb25OYW1lc1tpXTtcblxuICAgICAgaWYgKHR5cGVvZiBlbC5zdHlsZVt0cmFuc2l0aW9uTmFtZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRyYW5zaXRpb25FdmVudCA9IHRyYW5zaXRpb25zW3RyYW5zaXRpb25OYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJhbnNpdGlvbkV2ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHByZWZpeGVkIGFuaW1hdGlvbiBlbmQgZXZlbnQuXG4gICAqIEBwYXJhbSB7P0VsZW1lbnR9IG9wdEVsIEVsZW1lbnQgdG8gY2hlY2tcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldEFuaW1hdGlvbkV2ZW50KG9wdEVsKSB7XG4gICAgaWYgKGFuaW1hdGlvbkV2ZW50ICYmICFvcHRFbCkge1xuICAgICAgcmV0dXJuIGFuaW1hdGlvbkV2ZW50O1xuICAgIH1cblxuICAgIGFuaW1hdGlvbkV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5cbiAgICBjb25zdCBlbCA9IG9wdEVsIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3dzJyk7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IHtcbiAgICAgICdhbmltYXRpb24nOiAnYW5pbWF0aW9uZW5kJyxcbiAgICAgICdPQW5pbWF0aW9uJzogJ29BbmltYXRpb25FbmQnLFxuICAgICAgJ01vekFuaW1hdGlvbic6ICdhbmltYXRpb25lbmQnLFxuICAgICAgJ1dlYmtpdEFuaW1hdGlvbic6ICd3ZWJraXRBbmltYXRpb25FbmQnXG4gICAgfTtcbiAgICBjb25zdCBhbmltYXRpb25OYW1lcyA9IE9iamVjdC5rZXlzKGFuaW1hdGlvbnMpO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGFuaW1hdGlvbk5hbWVzLmxlbmd0aDtcbiAgICAgICAgICBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGFuaW1hdGlvbk5hbWUgPSBhbmltYXRpb25OYW1lc1tpXTtcblxuICAgICAgaWYgKHR5cGVvZiBlbC5zdHlsZVthbmltYXRpb25OYW1lXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgYW5pbWF0aW9uRXZlbnQgPSBhbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0aW9uRXZlbnQ7XG4gIH1cblxuICAvKipcbiAgICogSGlkZXMgYW4gZWxlbWVudCBzZXR0aW5nIHRoZSBkaXNwbGF5IHRvIG5vbmUuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgRWxlbWVudCB0byBiZSBoaWRkZW4uXG4gICAqL1xuICBzdGF0aWMgaGlkZShlbCkge1xuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH1cblxuICAvKipcbiAgICogU2hvd3MgYW4gZWxlbWVudCBieSByZW1vdmluZyB0aGUgZGlzcGxheSBwcm9wZXJ0eS4gVGhpcyBpcyBvbmx5IGludGVuZGVkXG4gICAqIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBET00uaGlkZS5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBFbGVtZW50IHRvIGJlIHNob3duLlxuICAgKi9cbiAgc3RhdGljIHNob3coZWwpIHtcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBlbGVtZW50IGlzIHZpc2libGUuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgRWxlbWVudCB0byBjaGVjay5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1Zpc2libGUoZWwpIHtcbiAgICByZXR1cm4gKGVsLm9mZnNldFBhcmVudCAhPT0gbnVsbCk7XG4gIH1cblxuICAvKipcbiAgICogRmlyZXMgYSBjdXN0b20gZXZlbnQgb24gdGhlIGdpdmVuIHRhcmdldC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgVGhlIHRhcmdldCBvZiB0aGUgZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudEluZm8gT3B0aW9uYWwgcGFyYW1ldGVyIHRvIHByb3ZpZGUgYWRkaXRpb25hbCBkYXRhXG4gICAqIHRvIHRoZSBldmVudC5cbiAgICovXG4gIHN0YXRpYyBmaXJlRXZlbnQodGFyZ2V0LCBldmVudFR5cGUsIGV2ZW50SW5mbyA9IHt9KSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgV1NDdXN0b21FdmVudChldmVudFR5cGUsIHtcbiAgICAgIGRldGFpbDogZXZlbnRJbmZvXG4gICAgfSk7XG5cbiAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYW4gaXRlcmFibGUgdG8gYW4gYXJyYXkuXG4gICAqIEBwYXJhbSB7Kn0gaXRlcmFibGUgRWxlbWVudCB0byBjb252ZXJ0IHRvIGFycmF5XG4gICAqIEByZXR1cm4ge0FycmF5fSB0aGUgZWxlbWVudCBjYXN0ZWQgdG8gYW4gYXJyYXkuXG4gICAqL1xuICBzdGF0aWMgdG9BcnJheShpdGVyYWJsZSkge1xuICAgIHJldHVybiBbXS5zbGljZS5jYWxsKGl0ZXJhYmxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZG9jdW1lbnQgaGFzIGZvY3VzIG9uIGFuIGlucHV0IG9yIGNvbnRlbnRlZGl0YWJsZVxuICAgKiBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBmb2N1c2VkIGVsZW1lbnQgaXMgYW4gaW5wdXQgb3IgY29udGVudFxuICAgKiBlZGl0YWJsZS5cbiAgICovXG4gIHN0YXRpYyBpc0ZvY3VzYWJsZUVsZW1lbnQoKSB7XG4gICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGlzQ29udGVudEVkaXRhYmxlID1cbiAgICAgICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmNvbnRlbnRFZGl0YWJsZSAhPT0gJ2luaGVyaXQnICYmXG4gICAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5jb250ZW50RWRpdGFibGUgIT09IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IGlzSW5wdXQgPSBbJ0lOUFVUJywgJ1NFTEVDVCcsICdPUFRJT04nLCAnVEVYVEFSRUEnXVxuICAgICAgICAgIC5pbmRleE9mKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQudGFnTmFtZSkgPiAtMTtcbiAgICAgIHJlc3VsdCA9IGlzSW5wdXQgfHwgaXNDb250ZW50RWRpdGFibGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbnRlZ2VyIHZhbHVlIG9mIGEgc3R5bGUgcHJvcGVydHkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIENTUyBwcm9wZXJ0eSB2YWx1ZS5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcHJvcGVydHkgd2l0aG91dCB0aGUgdW5pdHMuXG4gICAqL1xuICBzdGF0aWMgcGFyc2VTaXplKHByb3ApIHtcbiAgICByZXR1cm4gTnVtYmVyKHByb3AucmVwbGFjZSgvW15cXGRcXC5dL2csICcnKSk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgYSBIVE1MIHN0cnVjdHVyZSBhcm91bmQgYW4gZWxlbWVudC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtIHRoZSBlbGVtZW50IHRvIGJlIHdyYXBwZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgdGhlIG5ldyBlbGVtZW50IHRhZy5cbiAgICogQHJldHVybiB7RWxlbWVudH0gdGhlIG5ldyBlbGVtZW50LlxuICAgKi9cbiAgc3RhdGljIHdyYXAoZWxlbSwgdGFnKSB7XG4gICAgY29uc3Qgd3JhcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBlbGVtLnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKHdyYXAsIGVsZW0pO1xuICAgIHdyYXAuYXBwZW5kQ2hpbGQoZWxlbSk7XG5cbiAgICByZXR1cm4gd3JhcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIGFuZCBlbGVtZW50IGFmdGVyIGFub3RoZXIgZWxlbWVudC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtIHRoZSBlbGVtZW50IHRvIGJlIGluc2VydGVkLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCB0aGUgZWxlbWVudCB0byBiZSBpbnNlcnRlZCBhZnRlci5cbiAgICovXG4gIHN0YXRpYyBhZnRlcihlbGVtLCB0YXJnZXQpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0YXJnZXQucGFyZW50Tm9kZTtcblxuICAgIGlmIChwYXJlbnQubGFzdENoaWxkID09PSB0YXJnZXQpIHtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChlbGVtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShlbGVtLCB0YXJnZXQubmV4dFNpYmxpbmcpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IERPTSBmcm9tICcuLi91dGlscy9kb20nO1xuXG4vKipcbiAqIEF1dG9zbGlkZSBwbHVnaW4uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1dG9TbGlkZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1dlYlNsaWRlc30gd3NJbnN0YW5jZSBUaGUgV2ViU2xpZGVzIGluc3RhbmNlXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3Iod3NJbnN0YW5jZSkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtXZWJTbGlkZXN9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLndzXyA9IHdzSW5zdGFuY2U7XG4gICAgLyoqXG4gICAgICogSW50ZXJ2YWwgSUQgcmVmZXJlbmNlIGZvciB0aGUgYXV0b3NsaWRlLlxuICAgICAqIEB0eXBlIHs/bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pbnRlcnZhbF8gPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEludGVybmFsIHN0b3JlZCB0aW1lLlxuICAgICAqIEB0eXBlIHs/bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGltZSA9IHRoaXMud3NfLm9wdGlvbnMuYXV0b3NsaWRlO1xuXG4gICAgaWYgKHRoaXMudGltZSkge1xuICAgICAgRE9NLm9uY2Uod3NJbnN0YW5jZS5lbCwgJ3dzOmluaXQnLCB0aGlzLnBsYXkuYmluZCh0aGlzKSk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5vbkZvY3VzLmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBmb2N1cyBoYW5kbGVyLiBXaWxsIGRlY2lkZSBpZiBzdG9wcy9wbGF5IGRlcGVuZGluZyBvbiB0aGUgZm9jdXNlZFxuICAgKiBlbGVtZW50IGlmIGF1dG9zbGlkZSBpcyBhY3RpdmUuXG4gICAqL1xuICBvbkZvY3VzKCkge1xuICAgIGlmIChET00uaXNGb2N1c2FibGVFbGVtZW50KCkpIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pbnRlcnZhbF8gPT09IG51bGwpIHtcbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydHMgYXV0b3NsaWRpbmcgYWxsIHRoZSBzbGlkZXMgaWYgaXQncyBub3QgY3VycmVudGx5IGRvaW5nIGl0IGFuZCB0aGVcbiAgICogYXV0b3NsaWRlIG9wdGlvbiB3YXMgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDAuXG4gICAqIEBwYXJhbSB7P251bWJlcj19IHRpbWUgQW1vdW50IG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IHRvIGdvIHRvIG5leHQgc2xpZGVcbiAgICogYXV0b21hdGljYWxseS5cbiAgICovXG4gIHBsYXkodGltZSkge1xuICAgIGlmICh0eXBlb2YgdGltZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRpbWUgPSB0aGlzLnRpbWU7XG4gICAgfVxuXG4gICAgdGhpcy50aW1lID0gdGltZTtcblxuICAgIGlmICghdGhpcy5pbnRlcnZhbF8gJiYgdHlwZW9mIHRpbWUgPT09ICdudW1iZXInICYmIHRpbWUgPiAwKSB7XG4gICAgICB0aGlzLmludGVydmFsXyA9IHNldEludGVydmFsKHRoaXMud3NfLmdvTmV4dC5iaW5kKHRoaXMud3NfKSwgdGltZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIGF1dG9zbGlkaW5nIGFsbCB0aGUgc2xpZGVzLlxuICAgKi9cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5pbnRlcnZhbF8pIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbF8pO1xuICAgICAgdGhpcy5pbnRlcnZhbF8gPSBudWxsO1xuICAgIH1cbiAgfVxufVxuIiwiY29uc3QgQ0xJQ0tBQkxFX0VMUyA9IFtcbiAgJ0lOUFVUJyxcbiAgJ1NFTEVDVCcsXG4gICdPUFRJT04nLFxuICAnQlVUVE9OJyxcbiAgJ0EnLFxuICAnVEVYVEFSRUEnXG5dO1xuXG4vKipcbiAqIENsaWNrTmF2IHBsdWdpbiB0aGF0IGFsbG93cyB0byBjbGljayBvbiB0aGUgcGFnZSB0byBnZXQgdG8gdGhlIG5leHQgc2xpZGUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENsaWNrTmF2IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7V2ViU2xpZGVzfSB3c0luc3RhbmNlIFRoZSBXZWJTbGlkZXMgaW5zdGFuY2VcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3c0luc3RhbmNlKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1dlYlNsaWRlc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMud3NfID0gd3NJbnN0YW5jZTtcblxuICAgIGlmICh3c0luc3RhbmNlLm9wdGlvbnMuY2hhbmdlT25DbGljaykge1xuICAgICAgdGhpcy53c18uZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2xpY2tfLmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFjdHMgdG8gdGhlIGNsaWNrIGV2ZW50LiBJdCB3aWxsIGdvIHRvIHRoZSBuZXh0IHNsaWRlIHVubGVzcyB0aGUgZWxlbWVudFxuICAgKiBoYXMgYSBkYXRhLXByZXZlbnQtbmF2IGF0dHJpYnV0ZSBvciBpcyBvbiB0aGUgbGlzdCBvZiBDTElDS0FCTEVfRUxTLlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IFRoZSBjbGljayBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uQ2xpY2tfKGV2ZW50KSB7XG4gICAgaWYgKENMSUNLQUJMRV9FTFMuaW5kZXhPZihldmVudC50YXJnZXQudGFnTmFtZSkgPCAwICYmXG4gICAgICB0eXBlb2YgZXZlbnQudGFyZ2V0LmRhdGFzZXQucHJldmVudE5hdiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMud3NfLmdvTmV4dCgpO1xuICAgIH1cbiAgfVxufVxuIiwiY29uc3QgS2V5cyA9IHtcbiAgRU5URVI6IDEzLFxuICBTUEFDRTogMzIsXG4gIFJFX1BBR0U6IDMzLFxuICBBVl9QQUdFOiAzNCxcbiAgRU5EOiAzNSxcbiAgSE9NRTogMzYsXG4gIExFRlQ6IDM3LFxuICBVUDogMzgsXG4gIFJJR0hUOiAzOSxcbiAgRE9XTjogNDAsXG4gIFBMVVM6IFsxMDcsIDE3MSwgMTg3XSxcbiAgTUlOVVM6IFsxMDksIDE3MywgMTg5XSxcbiAgRVNDQVBFOiAyNyxcbiAgRjogNzBcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEtleXM7XG4iLCJpbXBvcnQgS2V5cyBmcm9tICcuLi91dGlscy9rZXlzJztcblxuY29uc3QgR1JJRF9JTUFHRSA9ICdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJnQUFBQVlBZycgK1xuICAnTUFBQUNkR2RWckFBQUFDVkJNVkVVQUFBQXRYc1V0WGNQRERQVVdBQUFBQTNSU1RsTUFabUh6WkZreEFBQUFGa2xFUVZRSTEyTScgK1xuICAnQUE5YkJSM0V4aEFKQjFpb29CUUJHd2dWRXMvUXR1QUFBQUFCSlJVNUVya0pnZ2c9PSc7XG5cbi8qKlxuICogR3JpZCBwbHVnaW4gdGhhdCBzaG93cyBhIGdyaWQgb24gdG9wIG9mIHRoZSBXZWJTbGlkZXMgZm9yIGVhc3kgcHJvdG90eXBpbmcuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyaWQge1xuICAvKipcbiAgICogQHBhcmFtIHtXZWJTbGlkZXN9IHdzSW5zdGFuY2UgVGhlIFdlYlNsaWRlcyBpbnN0YW5jZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdzSW5zdGFuY2UpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7V2ViU2xpZGVzfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy53c18gPSB3c0luc3RhbmNlO1xuXG4gICAgY29uc3QgQ1NTID0gYGJvZHkuYmFzZWxpbmUge1xuICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogdXJsKCR7R1JJRF9JTUFHRX0pIGxlZnQgdG9wIC44cmVtLy44cmVtO1xuICAgICAgICAgICAgICAgIH1gO1xuICAgIGNvbnN0IGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuXG4gICAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG5cbiAgICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gQ1NTO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShDU1MpKTtcbiAgICB9XG5cbiAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uS2V5UHJlc3NfLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFjdHMgdG8gdGhlIGtleWRvd24gZXZlbnQuIEl0IHJlYWN0cyB0byBFTlRFUiBrZXkgdG8gdG9nZ2xlIHRoZSBjbGFzcy5cbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCBUaGUga2V5IGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25LZXlQcmVzc18oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IEtleXMuRU5URVIpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnRvZ2dsZSgnYmFzZWxpbmUnKTtcbiAgICB9XG4gIH1cbn1cbiIsImNvbnN0IEhBU0ggPSAnI3NsaWRlJztcbmNvbnN0IHNsaWRlUmVnZXggPSAvI3NsaWRlPShcXGQrKS87XG5cbi8qKlxuICogU3RhdGljIGNsYXNzIHdpdGggbWV0aG9kcyB0byBtYW5pcHVsYXRlIGFuZCBleHRyYWN0IGluZm8gZnJvbSB0aGUgaGFzaCBvZlxuICogdGhlIFVSTC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGFzaCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1dlYlNsaWRlc30gd3NJbnN0YW5jZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdzSW5zdGFuY2UpIHtcbiAgICB0aGlzLndzXyA9IHdzSW5zdGFuY2U7XG5cbiAgICB3c0luc3RhbmNlLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ3dzOnNsaWRlLWNoYW5nZScsIEhhc2gub25TbGlkZUNoYW5nZV8pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgdGhpcy5vbkhhc2hDaGFuZ2VfLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBoYXNoY2hhbmdlIGV2ZW50IGhhbmRsZXIsIG1ha2VzIHRoZSBXZWJTbGlkZSBpbnN0YW5jZSBuYXZpZ2F0ZSB0byB0aGVcbiAgICogbmVlZGVkIHNsaWRlLlxuICAgKi9cbiAgb25IYXNoQ2hhbmdlXygpIHtcbiAgICBjb25zdCBuZXdTbGlkZUluZGV4ID0gSGFzaC5nZXRTbGlkZU51bWJlcigpO1xuXG4gICAgaWYgKG5ld1NsaWRlSW5kZXggIT09IG51bGwpIHtcbiAgICAgIHRoaXMud3NfLmdvVG9TbGlkZShuZXdTbGlkZUluZGV4KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlciBmb3IgdGhlIHNsaWRlIGNoYW5nZSBldmVudCB3aGljaCB1cGRhdGVzIHRoZSBzbGlkZSBvbiB0aGUgaGFzaC5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBvblNsaWRlQ2hhbmdlXyhldmVudCkge1xuICAgIEhhc2guc2V0U2xpZGVOdW1iZXIoZXZlbnQuZGV0YWlsLmN1cnJlbnRTbGlkZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc2xpZGUgbnVtYmVyIGZyb20gdGhlIGhhc2ggYnkgYSByZWdleCBtYXRjaGluZyBgI3NsaWRlPWAgYW5kIGdldHNcbiAgICogdGhlIG51bWJlciBhZnRlciBpdC4gSWYgdGhlIG51bWJlciBpcyBpbnZhbGlkIG9yIGxlc3MgdGhhbiAwLCBpdCB3aWxsXG4gICAqIHJldHVybiBudWxsIGFzIGFuIGludmFsaWQgdmFsdWUuXG4gICAqIEByZXR1cm4gez9udW1iZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0U2xpZGVOdW1iZXIoKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IGRvY3VtZW50LmxvY2F0aW9uLmhhc2gubWF0Y2goc2xpZGVSZWdleCk7XG4gICAgbGV0IHNsaWRlID0gMDtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdHMpKSB7XG4gICAgICBzbGlkZSA9IHBhcnNlSW50KHJlc3VsdHNbMV0sIDEwKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNsaWRlICE9PSAnbnVtYmVyJyB8fCBzbGlkZSA8IDAgfHwgIUFycmF5LmlzQXJyYXkocmVzdWx0cykpIHtcbiAgICAgIHNsaWRlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2xpZGUtLTsgLy8gQ29udmVydCB0byAwIGluZGV4XG4gICAgfVxuXG4gICAgcmV0dXJuIHNsaWRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0IHdpbGwgdXBkYXRlIHRoZSBoYXNoIChpZiBpdCdzIGRpZmZlcmVudCkgc28gaXQgcmVmbGVjdHMgdGhlIHNsaWRlXG4gICAqIG51bWJlciBiZWluZyB2aXNpYmxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgb2YgdGhlIHNsaWRlIHdlJ3JlIHRyYW5zaXRpb25pbmcgdG8uXG4gICAqL1xuICBzdGF0aWMgc2V0U2xpZGVOdW1iZXIobnVtYmVyKSB7XG4gICAgaWYgKEhhc2guZ2V0U2xpZGVOdW1iZXIoKSAhPT0gKG51bWJlciAtIDEpKSB7XG4gICAgICBoaXN0b3J5LnB1c2hTdGF0ZSh7XG4gICAgICAgIHNsaWRlSTogbnVtYmVyIC0gMVxuICAgICAgfSwgYFNsaWRlICR7bnVtYmVyfWAsIGAke0hBU0h9PSR7bnVtYmVyfWApO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IEtleXMgZnJvbSAnLi4vdXRpbHMva2V5cyc7XG5pbXBvcnQgRE9NIGZyb20gJy4uL3V0aWxzL2RvbSc7XG5cbi8qKlxuICogS2V5Ym9hcmQgaW50ZXJhY3Rpb24gcGx1Z2luLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLZXlib2FyZCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1dlYlNsaWRlc30gd3NJbnN0YW5jZSBUaGUgV2ViU2xpZGVzIGluc3RhbmNlXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3Iod3NJbnN0YW5jZSkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtXZWJTbGlkZXN9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLndzXyA9IHdzSW5zdGFuY2U7XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vbktleVByZXNzXy5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVhY3RzIHRvIHRoZSBrZXlkb3duIGV2ZW50LiBJdCByZWFjdHMgdG8gdGhlIGFycm93cyBhbmQgc3BhY2Uga2V5XG4gICAqIGRlcGVuZGluZyBvbiB0aGUgbGF5b3V0IG9mIHRoZSBwYWdlLlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IFRoZSBrZXkgZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbktleVByZXNzXyhldmVudCkge1xuICAgIGxldCBtZXRob2Q7XG4gICAgbGV0IGFyZ3VtZW50O1xuXG4gICAgaWYgKERPTS5pc0ZvY3VzYWJsZUVsZW1lbnQoKSB8fCB0aGlzLndzXy5pc0Rpc2FibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGV2ZW50LndoaWNoKSB7XG4gICAgICBjYXNlIEtleXMuQVZfUEFHRTpcbiAgICAgIGNhc2UgS2V5cy5TUEFDRTpcbiAgICAgICAgbWV0aG9kID0gdGhpcy53c18uZ29OZXh0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgS2V5cy5SRV9QQUdFOlxuICAgICAgICBtZXRob2QgPSB0aGlzLndzXy5nb1ByZXY7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLZXlzLkhPTUU6XG4gICAgICAgIG1ldGhvZCA9IHRoaXMud3NfLmdvVG9TbGlkZTtcbiAgICAgICAgYXJndW1lbnQgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgS2V5cy5FTkQ6XG4gICAgICAgIG1ldGhvZCA9IHRoaXMud3NfLmdvVG9TbGlkZTtcbiAgICAgICAgYXJndW1lbnQgPSB0aGlzLndzXy5tYXhTbGlkZV8gLSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgS2V5cy5ET1dOOlxuICAgICAgICBtZXRob2QgPSB0aGlzLndzXy5pc1ZlcnRpY2FsID8gdGhpcy53c18uZ29OZXh0IDogbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtleXMuVVA6XG4gICAgICAgIG1ldGhvZCA9IHRoaXMud3NfLmlzVmVydGljYWwgPyB0aGlzLndzXy5nb1ByZXYgOiBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgS2V5cy5MRUZUOlxuICAgICAgICBtZXRob2QgPSAhdGhpcy53c18uaXNWZXJ0aWNhbCA/IHRoaXMud3NfLmdvUHJldiA6IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLZXlzLlJJR0hUOlxuICAgICAgICBtZXRob2QgPSAhdGhpcy53c18uaXNWZXJ0aWNhbCA/IHRoaXMud3NfLmdvTmV4dCA6IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLZXlzLkY6XG4gICAgICAgIG1ldGhvZCA9IHRoaXMud3NfLmZ1bGxzY3JlZW47XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChtZXRob2QpIHtcbiAgICAgIG1ldGhvZC5jYWxsKHRoaXMud3NfLCBhcmd1bWVudCk7XG4gICAgICAvLyBQcmV2ZW50cyBGaXJlZm94IGtleSBldmVudHMuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IERPTSBmcm9tICcuLi91dGlscy9kb20nO1xuXG5jb25zdCBFTEVNRU5UX0lEID0ge1xuICBOQVY6ICduYXZpZ2F0aW9uJyxcbiAgTkVYVDogJ25leHQnLFxuICBQUkVWOiAncHJldmlvdXMnLFxuICBDT1VOVEVSOiAnY291bnRlcidcbn07XG5cbmNvbnN0IExBQkVMUyA9IHtcbiAgVkVSVElDQUw6IHtcbiAgICBORVhUOiAn4oaTJyxcbiAgICBQUkVWOiAn4oaRJ1xuICB9LFxuICBIT1JJWk9OVEFMOiB7XG4gICAgTkVYVDogJ+KGkicsXG4gICAgUFJFVjogJ+KGkCdcbiAgfVxufTtcblxuLyoqXG4gKiBOYXZpZ2F0aW9uIHBsdWdpbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2aWdhdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1dlYlNsaWRlc30gd3NJbnN0YW5jZSBUaGUgV2ViU2xpZGVzIGluc3RhbmNlXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3Iod3NJbnN0YW5jZSkge1xuICAgIGNvbnN0IGFycm93TGFiZWxzID0gd3NJbnN0YW5jZS5pc1ZlcnRpY2FsID9cbiAgICAgICAgTEFCRUxTLlZFUlRJQ0FMIDogTEFCRUxTLkhPUklaT05UQUw7XG4gICAgLyoqXG4gICAgICogTmF2aWdhdGlvbiBlbGVtZW50LlxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZWwgPSBET00uY3JlYXRlTm9kZSgnZGl2JywgJ25hdmlnYXRpb24nKTtcbiAgICAvKipcbiAgICAgKiBOZXh0IGJ1dHRvbi5cbiAgICAgKiBAdHlwZSB7RWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLm5leHQgPSBOYXZpZ2F0aW9uLmNyZWF0ZUFycm93KEVMRU1FTlRfSUQuTkVYVCwgYXJyb3dMYWJlbHMuTkVYVCk7XG4gICAgLyoqXG4gICAgICogUHJldiBidXR0b24uXG4gICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5wcmV2ID0gTmF2aWdhdGlvbi5jcmVhdGVBcnJvdyhFTEVNRU5UX0lELlBSRVYsIGFycm93TGFiZWxzLlBSRVYpO1xuICAgIC8qKlxuICAgICAqIENvdW50ZXIgRWxlbWVudC5cbiAgICAgKiBAdHlwZSB7RWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNvdW50ZXIgPSBOYXZpZ2F0aW9uLmNyZWF0ZUNvdW50ZXIoRUxFTUVOVF9JRC5DT1VOVEVSLCB3c0luc3RhbmNlKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7V2ViU2xpZGVzfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy53c18gPSB3c0luc3RhbmNlO1xuXG4gICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh0aGlzLm5leHQpO1xuICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGhpcy5wcmV2KTtcbiAgICB0aGlzLmVsLmFwcGVuZENoaWxkKHRoaXMuY291bnRlcik7XG5cbiAgICB0aGlzLndzXy5lbC5hcHBlbmRDaGlsZCh0aGlzLmVsKTtcbiAgICB0aGlzLmJpbmRFdmVudHNfKCk7XG4gIH1cblxuICAvKipcbiAgICogQmluZCBhbGwgZXZlbnRzIGZvciB0aGUgbmF2aWdhdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGJpbmRFdmVudHNfKCkge1xuICAgIHRoaXMud3NfLmVsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAnd3M6c2xpZGUtY2hhbmdlJywgdGhpcy5vblNsaWRlQ2hhbmdlZF8uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5uZXh0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkJ1dHRvbkNsaWNrZWRfLmJpbmQodGhpcykpO1xuICAgIHRoaXMucHJldi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25CdXR0b25DbGlja2VkXy5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmNvdW50ZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQnV0dG9uQ2xpY2tlZF8uYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY291bnRlciBpbnNpZGUgdGhlIG5hdmlnYXRpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gY3VycmVudCBDdXJyZW50IHNsaWRlIG51bWJlci5cbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBtYXggTWF4IHNsaWRlIG51bWJlci5cbiAgICovXG4gIHVwZGF0ZUNvdW50ZXIoY3VycmVudCwgbWF4KSB7XG4gICAgaWYgKHRoaXMud3NfLm9wdGlvbnMuc2hvd0luZGV4KSB7XG4gICAgICB0aGlzLmNvdW50ZXIuY2hpbGROb2Rlc1swXS50ZXh0Q29udGVudCA9IGAke2N1cnJlbnR9IC8gJHttYXh9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb3VudGVyLnRleHRDb250ZW50ID0gYCR7Y3VycmVudH0gLyAke21heH1gO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFycm93IHRvIG5hdmlnYXRlLlxuICAgKiBAcGFyYW0geyFTdHJpbmd9IGlkIERlc2lyZWQgSUQgZm9yIHRoZSBhcnJvdy5cbiAgICogQHBhcmFtIHshU3RyaW5nfSB0ZXh0IERlc2lyZWQgdGV4dCBmb3IgdGhlIGFycm93LlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSBUaGUgYXJyb3cgZWxlbWVudC5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBcnJvdyhpZCwgdGV4dCkge1xuICAgIGNvbnN0IGFycm93ID0gRE9NLmNyZWF0ZU5vZGUoJ2EnLCBpZCwgdGV4dCk7XG4gICAgYXJyb3cuaHJlZiA9ICcjJztcbiAgICBhcnJvdy50aXRsZSA9ICdBcnJvdyBLZXlzJztcblxuICAgIHJldHVybiBhcnJvdztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBuYXZpZ2F0aW9uIGNvdW50ZXIuXG4gICAqIEBwYXJhbSB7IVN0cmluZ30gaWQgRGVzaXJlZCBJRCBmb3IgdGhlIGNvdW50ZXIuXG4gICAqIEBwYXJhbSB7V2ViU2xpZGVzfSB3c18gV2ViU2xpZGVzIG9iamVjdC5cbiAgICogQHJldHVybiB7RWxlbWVudH0gVGhlIGFycm93IGVsZW1lbnQuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQ291bnRlcihpZCwgd3NfKSB7XG4gICAgY29uc3QgY291bnRlciA9IERPTS5jcmVhdGVOb2RlKCdzcGFuJywgaWQpO1xuICAgIGlmICh3c18ub3B0aW9ucy5zaG93SW5kZXgpIHtcbiAgICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICBsaW5rLmhyZWYgPSAnIyc7XG4gICAgICBsaW5rLnRpdGxlID0gJ1ZpZXcgYWxsIHNsaWRlcyc7XG4gICAgICBjb3VudGVyLmFwcGVuZENoaWxkKGxpbmspO1xuICAgIH1cblxuICAgIHJldHVybiBjb3VudGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFNsaWRlIENoYW5nZSBldmVudCBoYW5kbGVyLiBXaWxsIHVwZGF0ZSB0aGUgdGV4dCBvbiB0aGUgbmF2aWdhdGlvbi5cbiAgICogQHBhcmFtIHtDdXN0b21FdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uU2xpZGVDaGFuZ2VkXyhldmVudCkge1xuICAgIHRoaXMudXBkYXRlQ291bnRlcihldmVudC5kZXRhaWwuY3VycmVudFNsaWRlLCBldmVudC5kZXRhaWwuc2xpZGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGNsaWNrcyBvbiB0aGUgbmV4dC9wcmV2IGJ1dHRvbnMuXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uQnV0dG9uQ2xpY2tlZF8oZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMubmV4dCkge1xuICAgICAgdGhpcy53c18uZ29OZXh0KCk7XG4gICAgfSBlbHNlIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMucHJldikge1xuICAgICAgdGhpcy53c18uZ29QcmV2KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud3NfLnRvZ2dsZVpvb20oKTtcbiAgICB9XG4gIH1cbn1cbiIsImNvbnN0IFVBID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbi8qKlxuICogTW9iaWxlIGRldGVjdG9yIGhlbHBlciBjbGFzcy4gVGVzdHMgdGhlIFVzZXIgQWdlbnQgdG8gc2VlIGlmIHdlJ3JlLCBsaWtlbHksXG4gKiBvbiBhIG1vYmlsZSBkZXZpY2UuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vYmlsZURldGVjdG9yIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGRldmljZSBpcyBBbmRyb2lkIG9yIG5vdC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0FuZHJvaWQoKSB7XG4gICAgcmV0dXJuICEhVUEubWF0Y2goL0FuZHJvaWQvaSk7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgZGV2aWNlIGlzIEJsYWNrQmVycnkgb3Igbm90LlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzQmxhY2tCZXJyeSgpIHtcbiAgICByZXR1cm4gISFVQS5tYXRjaCgvQmxhY2tCZXJyeS9pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBkZXZpY2UgaXMgaU9TIG9yIG5vdC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc2lPUygpIHtcbiAgICByZXR1cm4gISFVQS5tYXRjaCgvaVBhZHxpUGhvbmV8aVBvZC9pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBkZXZpY2UgaXMgT3BlcmEgb3Igbm90LlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzT3BlcmEoKSB7XG4gICAgcmV0dXJuICEhVUEubWF0Y2goL09wZXJhIE1pbmkvaSk7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgZGV2aWNlIGlzIFdpbmRvd3Mgb3Igbm90LlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzV2luZG93cygpIHtcbiAgICByZXR1cm4gISFVQS5tYXRjaCgvSUVNb2JpbGUvaSk7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgZGV2aWNlIGlzIFdpbmRvd3MgUGhvbmUgb3Igbm90LlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzV2luZG93c1Bob25lKCkge1xuICAgIHJldHVybiAhIVVBLm1hdGNoKC9XaW5kb3dzIFBob25lL2kpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGRldmljZSBpcyBhbnkgbW9iaWxlIGRldmljZSBvciBub3QuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNBbnkoKSB7XG4gICAgcmV0dXJuIE1vYmlsZURldGVjdG9yLmlzQW5kcm9pZCgpIHx8XG4gICAgTW9iaWxlRGV0ZWN0b3IuaXNCbGFja0JlcnJ5KCkgfHxcbiAgICBNb2JpbGVEZXRlY3Rvci5pc2lPUygpIHx8XG4gICAgTW9iaWxlRGV0ZWN0b3IuaXNPcGVyYSgpIHx8XG4gICAgTW9iaWxlRGV0ZWN0b3IuaXNXaW5kb3dzKCkgfHxcbiAgICBNb2JpbGVEZXRlY3Rvci5pc1dpbmRvd3NQaG9uZSgpO1xuICB9XG59XG4iLCJpbXBvcnQgTW9iaWxlRGV0ZWN0b3IgZnJvbSAnLi4vdXRpbHMvbW9iaWxlLWRldGVjdG9yJztcblxuXG4vKipcbiAqIFNjcm9sbCBwbHVnaW4uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjcm9sbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1dlYlNsaWRlc30gd3NJbnN0YW5jZSBUaGUgV2ViU2xpZGVzIGluc3RhbmNlXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3Iod3NJbnN0YW5jZSkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtXZWJTbGlkZXN9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLndzXyA9IHdzSW5zdGFuY2U7XG4gICAgLyoqXG4gICAgICogV2hlcmUgdGhlIHNjcm9sbCBpcyBnb2luZyB0byBoYXBwZW4uIFRoZSBXZWJTbGlkZXMgZWxlbWVudC5cbiAgICAgKiBAdHlwZSB7RWxlbWVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc2Nyb2xsQ29udGFpbmVyXyA9IHdzSW5zdGFuY2UuZWw7XG4gICAgLyoqXG4gICAgICogV2hldGhlciBtb3ZlbWVudCBpcyBoYXBwZW5pbmcgdXAgb3IgZG93bi5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaXNHb2luZ1VwXyA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgbW92ZW1lbnQgaXMgaGFwcGVuaW5nIGxlZnQgb3IgcmlnaHQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmlzR29pbmdMZWZ0XyA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFRpbWVvdXQgaWQgaG9sZGVyLlxuICAgICAqIEB0eXBlIHs/bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50aW1lb3V0XyA9IG51bGw7XG5cbiAgICAvLyBEaXNhYmxpbmcgZnJvbSBvcHRpb25cbiAgICBpZiAoIXRoaXMud3NfLm9wdGlvbnMubmF2aWdhdGVPblNjcm9sbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghTW9iaWxlRGV0ZWN0b3IuaXNBbnkoKSkge1xuICAgICAgICB0aGlzLnNjcm9sbENvbnRhaW5lcl8uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICd3aGVlbCcsIHRoaXMub25Nb3VzZVdoZWVsXy5iaW5kKHRoaXMpKTtcblxuICAgICAgICBpZiAoIXdzSW5zdGFuY2UuaXNWZXJ0aWNhbCkge1xuICAgICAgICAgIHdzSW5zdGFuY2UuZWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgJ3dzOnNsaWRlLWNoYW5nZScsIHRoaXMub25TbGlkZUNoYW5nZV8uYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2hlbiB0aGUgc2xpZGVzIGNoYW5nZSwgc2V0IGFuIGlubmVyIHRpbWVvdXQgdG8gYXZvaWQgcHJlbWF0dXJlbHlcbiAgICogY2hhbmdpbmcgdG8gdGhlIG5leHQgc2xpZGUgYWdhaW4uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvblNsaWRlQ2hhbmdlXygpIHtcbiAgICB0aGlzLnRpbWVvdXRfID0gc2V0VGltZW91dChcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHRoaXMudGltZW91dF8gPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICB0aGlzLndzXy5vcHRpb25zLnNjcm9sbFdhaXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWN0cyB0byB0aGUgd2hlZWwgZXZlbnQuIERldGVjdHMgd2hldGhlciBpcyBnb2luZyB1cCBvciBkb3duIGFuZCBkZWNpZGVzXG4gICAqIGlmIGl0IG5lZWRzIHRvIG1vdmUgdGhlIHNsaWRlIGJhc2VkIG9uIHRoZSBhbW91bnQgb2YgZGVsdGEuXG4gICAqIEBwYXJhbSB7V2hlZWxFdmVudH0gZXZlbnQgVGhlIFdoZWVsIEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25Nb3VzZVdoZWVsXyhldmVudCkge1xuICAgIGlmICh0aGlzLndzXy5pc0Rpc2FibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy53c18uaXNNb3ZpbmcgfHwgdGhpcy50aW1lb3V0Xykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGaXJlZm94IHVzZXMgbGluZXMgaW5zdGVhZCBvZiBwaXhlbHMgZm9yIGRlbHRhXG4gICAgY29uc3QgbGluZXNUb1B4ID0gZXZlbnQuZGVsdGFNb2RlICogdGhpcy53c18ub3B0aW9ucy5taW5XaGVlbERlbHRhO1xuICAgIGNvbnN0IHtkZWx0YVk6IHdoZWVsRGVsdGFZLCBkZWx0YVg6IHdoZWVsRGVsdGFYfSA9IGV2ZW50O1xuICAgIGNvbnN0IGlzVmVydGljYWwgPSB0aGlzLndzXy5pc1ZlcnRpY2FsO1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbE1vdmVtZW50ID0gTWF0aC5hYnMod2hlZWxEZWx0YVgpID4gTWF0aC5hYnMod2hlZWxEZWx0YVkpO1xuICAgIHRoaXMuaXNHb2luZ1VwXyA9IHdoZWVsRGVsdGFZIDwgMDtcbiAgICB0aGlzLmlzR29pbmdMZWZ0XyA9IHdoZWVsRGVsdGFYIDwgMDtcblxuXG4gICAgLy8gSWYgd2UncmUgbWFpbmx5IG1vdmluZyBob3Jpem9udGFsbHksIHByZXZlbnQgZGVmYXVsdFxuICAgIGlmIChpc0hvcml6b250YWxNb3ZlbWVudCkge1xuICAgICAgaWYgKCFpc1ZlcnRpY2FsKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB3ZSdyZSBtb3ZpbmcgaG9yaXpvbnRhbGx5IGJ1dCB0aGlzIGlzIHZlcnRpY2FsLCByZXR1cm4gdG8gYXZvaWRcbiAgICAgICAgLy8gdW53YW50ZWQgbmF2aWdhdGlvbi5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChNYXRoLmFicyh3aGVlbERlbHRhWSArIGxpbmVzVG9QeCkgPj0gdGhpcy53c18ub3B0aW9ucy5taW5XaGVlbERlbHRhIHx8XG4gICAgICAgIE1hdGguYWJzKHdoZWVsRGVsdGFYICsgbGluZXNUb1B4KSA+PSB0aGlzLndzXy5vcHRpb25zLm1pbldoZWVsRGVsdGEpIHtcbiAgICAgIGlmICgoaXNIb3Jpem9udGFsTW92ZW1lbnQgJiYgdGhpcy5pc0dvaW5nTGVmdF8pIHx8XG4gICAgICAgICAgKCFpc0hvcml6b250YWxNb3ZlbWVudCAmJiB0aGlzLmlzR29pbmdVcF8pKSB7XG4gICAgICAgIHRoaXMud3NfLmdvUHJldigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53c18uZ29OZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgTW9iaWxlRGV0ZWN0b3IgZnJvbSAnLi4vdXRpbHMvbW9iaWxlLWRldGVjdG9yJztcblxuY29uc3QgRVZFTlRTID0ge1xuICB0b3VjaDoge1xuICAgIFNUQVJUOiAndG91Y2hzdGFydCcsXG4gICAgTU9WRTogJ3RvdWNobW92ZScsXG4gICAgRU5EOiAndG91Y2hlbmQnXG4gIH0sXG4gIHBvaW50ZXI6IHtcbiAgICBTVEFSVDogJ3BvaW50ZXJkb3duJyxcbiAgICBNT1ZFOiAncG9pbnRlcm1vdmUnLFxuICAgIEVORDogJ3BvaW50ZXJ1cCdcbiAgfVxufTtcblxuLyoqXG4gKiBUb3VjaCBwbHVnaW4uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvdWNoIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7V2ViU2xpZGVzfSB3c0luc3RhbmNlIFRoZSBXZWJTbGlkZXMgaW5zdGFuY2VcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3c0luc3RhbmNlKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1dlYlNsaWRlc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMud3NfID0gd3NJbnN0YW5jZTtcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHBvc2l0aW9uIGZvciB0aGUgWCBjb29yZGluYXRlLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0WF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogU3RhcnQgcG9zaXRpb24gZm9yIHRoZSBZIGNvb3JkaW5hdGUuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc3RhcnRZXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBwb3NpdGlvbiBmb3IgdGhlIFggY29vcmQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZW5kWF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogU3RhcnQgcG9zaXRpb24gZm9yIHRoZSBZIGNvb3JkLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmVuZFlfID0gMDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaXMgZW5hYmxlZCBvciBub3QuIE9ubHkgZW5hYmxlZCBmb3IgdG91Y2ggZGV2aWNlcy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaXNFbmFibGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGlzIGEgZ2VzdHVyZSBvciBub3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmlzR2VzdHVyZSA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU3RvcmVzIHN0YXJ0IHRvdWNoIGV2ZW50ICh4LCB5KS5cbiAgICAgKiBAdHlwZSB7YXJyYXl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0VG91Y2hlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogU3RvcmVzIGVuZCB0b3VjaCBldmVudCAoeCwgeSkuXG4gICAgICogQHR5cGUge2FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5lbmRUb3VjaGVzID0gW107XG5cbiAgICBsZXQgZXZlbnRzO1xuXG4gICAgaWYgKE1vYmlsZURldGVjdG9yLmlzQW55KCkpIHtcbiAgICAgIC8vIExpa2VseSBJRVxuICAgICAgaWYgKHdpbmRvdy5Qb2ludGVyRXZlbnQgJiYgKFxuICAgICAgICAgIE1vYmlsZURldGVjdG9yLmlzV2luZG93cygpIHx8IE1vYmlsZURldGVjdG9yLmlzV2luZG93c1Bob25lKCkpKSB7XG4gICAgICAgIGV2ZW50cyA9IEVWRU5UUy5wb2ludGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXZlbnRzID0gRVZFTlRTLnRvdWNoO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlzRW5hYmxlZCA9IHRydWU7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50cy5TVEFSVCwgdGhpcy5vblN0YXJ0Xy5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50cy5NT1ZFLCB0aGlzLm9uTW92ZV8uYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudHMuRU5ELCB0aGlzLm9uU3RvcF8uYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCB0b3VjaCBoYW5kbGVyLiBTYXZlcyBzdGFydGluZyBwb2ludHMuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBUb3VjaCBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uU3RhcnRfKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMud3NfLmlzRGlzYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGluZm8gPSBUb3VjaC5ub3JtYWxpemVFdmVudEluZm8oZXZlbnQpO1xuXG4gICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLnN0YXJ0WF8gPSBpbmZvLng7XG4gICAgICB0aGlzLnN0YXJ0WV8gPSBpbmZvLnk7XG4gICAgICB0aGlzLmVuZFhfID0gaW5mby54O1xuICAgICAgdGhpcy5lbmRZXyA9IGluZm8ueTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5zdGFydFRvdWNoZXMgPSBUb3VjaC5nZXRUb3VjaENvb3JkaW5hdGVzKGV2ZW50KTtcbiAgICAgIHRoaXMuZW5kVG91Y2hlcyA9IHRoaXMuc3RhcnRUb3VjaGVzO1xuICAgICAgdGhpcy5pc0dlc3R1cmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHRvdWNoIGhhbmRsZXIuIFNhdmVzIGVuZCBwb2ludHMuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBUb3VjaCBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uTW92ZV8oZXZlbnQpIHtcbiAgICBpZiAodGhpcy53c18uaXNEaXNhYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaW5mbyA9IFRvdWNoLm5vcm1hbGl6ZUV2ZW50SW5mbyhldmVudCk7XG5cbiAgICBpZiAodGhpcy5pc0dlc3R1cmUpIHtcbiAgICAgIHRoaXMuZW5kVG91Y2hlcyA9IFRvdWNoLmdldFRvdWNoQ29vcmRpbmF0ZXMoZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVuZFhfID0gaW5mby54O1xuICAgICAgdGhpcy5lbmRZXyA9IGluZm8ueTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RvcCB0b3VjaCBoYW5kbGVyLiBDaGVja3MgaWYgaXQgbmVlZHMgdG8gbWFrZSBhbnkgYWN0aW9ucy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uU3RvcF8oKSB7XG4gICAgaWYgKHRoaXMud3NfLmlzRGlzYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzR2VzdHVyZSkge1xuICAgICAgY29uc3Qgc3RhcnREaXN0YW5jZSA9IE1hdGguc3FydChcbiAgICAgICAgTWF0aC5wb3codGhpcy5zdGFydFRvdWNoZXNbMF0ueCAtIHRoaXMuc3RhcnRUb3VjaGVzWzFdLngsIDIpICtcbiAgICAgICAgTWF0aC5wb3codGhpcy5zdGFydFRvdWNoZXNbMF0ueSAtIHRoaXMuc3RhcnRUb3VjaGVzWzFdLnksIDIpXG4gICAgICApO1xuICAgICAgY29uc3QgZW5kRGlzdGFuY2UgPSBNYXRoLnNxcnQoXG4gICAgICAgIE1hdGgucG93KHRoaXMuZW5kVG91Y2hlc1swXS54IC0gdGhpcy5lbmRUb3VjaGVzWzFdLngsIDIpICtcbiAgICAgICAgTWF0aC5wb3codGhpcy5lbmRUb3VjaGVzWzBdLnkgLSB0aGlzLmVuZFRvdWNoZXNbMV0ueSwgMilcbiAgICAgICk7XG4gICAgICBpZiAoc3RhcnREaXN0YW5jZSA+IGVuZERpc3RhbmNlKSB7XG4gICAgICAgIC8vIFBpbmNoIGdlc3R1cmVcbiAgICAgICAgdGhpcy53c18udG9nZ2xlWm9vbSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5pc0dlc3R1cmUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGlmZlggPSB0aGlzLnN0YXJ0WF8gLSB0aGlzLmVuZFhfO1xuICAgICAgY29uc3QgZGlmZlkgPSB0aGlzLnN0YXJ0WV8gLSB0aGlzLmVuZFlfO1xuXG4gICAgICAvLyBJdCdzIGFuIGhvcml6b250YWwgZHJhZ1xuICAgICAgaWYgKE1hdGguYWJzKGRpZmZYKSA+IE1hdGguYWJzKGRpZmZZKSkge1xuICAgICAgICBpZiAoZGlmZlggPCAtdGhpcy53c18ub3B0aW9ucy5zbGlkZU9mZnNldCkge1xuICAgICAgICAgIHRoaXMud3NfLmdvUHJldigpO1xuICAgICAgICB9IGVsc2UgaWYoZGlmZlggPiB0aGlzLndzXy5vcHRpb25zLnNsaWRlT2Zmc2V0KSB7XG4gICAgICAgICAgdGhpcy53c18uZ29OZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IFgsWSBjb29yZGluYXRlcyBmcm9tIHRvdWNoIHBvaW50ZXJzLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0VG91Y2hDb29yZGluYXRlcyhldmVudCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHg6IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgeTogZXZlbnQudG91Y2hlc1swXS5jbGllbnRZXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB4OiBldmVudC50b3VjaGVzWzFdLmNsaWVudFgsXG4gICAgICAgIHk6IGV2ZW50LnRvdWNoZXNbMV0uY2xpZW50WVxuICAgICAgfVxuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplcyBhbiBldmVudCB0byBkZWFsIHdpdGggZGlmZmVyZW5jZXMgYmV0d2VlbiBQb2ludGVyRXZlbnQgYW5kXG4gICAqIFRvdWNoRXZlbnQuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEByZXR1cm4ge09iamVjdH0gTm9ybWFsaXNlZCB0b3VjaCBwb2ludHMuXG4gICAqL1xuICBzdGF0aWMgbm9ybWFsaXplRXZlbnRJbmZvKGV2ZW50KSB7XG4gICAgbGV0IHRvdWNoRXZlbnQgPSB7cGFnZVg6IDAsIHBhZ2VZOiAwfTtcblxuICAgIGlmICh0eXBlb2YgZXZlbnQuY2hhbmdlZFRvdWNoZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0b3VjaEV2ZW50ID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQub3JpZ2luYWxFdmVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIGV2ZW50Lm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0b3VjaEV2ZW50ID0gZXZlbnQub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICB9XG5cbiAgICBjb25zdCB4ID0gZXZlbnQub2Zmc2V0WCB8fCBldmVudC5sYXllclggfHwgdG91Y2hFdmVudC5wYWdlWDtcbiAgICBjb25zdCB5ID0gZXZlbnQub2Zmc2V0WSB8fCBldmVudC5sYXllclkgfHwgdG91Y2hFdmVudC5wYWdlWTtcblxuICAgIHJldHVybiB7eCwgeX07XG4gIH1cbn1cbiIsImltcG9ydCBET00gZnJvbSAnLi4vdXRpbHMvZG9tJztcblxuY29uc3QgQ0xBU1NFUyA9IHtcbiAgU0xJREU6ICdzbGlkZScsXG4gIENVUlJFTlQ6ICdjdXJyZW50J1xufTtcblxuY29uc3QgRXZlbnRzID0ge1xuICBFTlRFUjogJ2RvbTplbnRlcicsXG4gIExFQVZFOiAnZG9tOmxlYXZlJyxcbiAgRU5BQkxFOiAnc2xpZGU6ZW5hYmxlJyxcbiAgRElTQUJMRTogJ3NsaWRlOmRpc2FibGUnXG59O1xuXG4vKipcbiAqIFdyYXBwZXIgZm9yIHRoZSBTbGlkZSBzZWN0aW9uLlxuICovXG5jbGFzcyBTbGlkZSB7XG4gIC8qKlxuICAgKiBCb290c3RyYXBzIHRoZSBzbGlkZSBieSBzYXZpbmcgc29tZSBkYXRhLCBhZGRpbmcgYSBjbGFzcyBhbmQgaGlkaW5nIGl0LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIFNlY3Rpb24gZWxlbWVudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGkgWmVybyBiYXNlZCBpbmRleCBvZiB0aGUgc2xpZGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbCwgaSkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZWwgPSBlbDtcbiAgICAvKipcbiAgICAgKiBUaGUgc2VjdGlvbidzIHBhcmVudC5cbiAgICAgKiBAdHlwZSB7Tm9kZX1cbiAgICAgKi9cbiAgICB0aGlzLnBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmkgPSBpO1xuXG4gICAgdGhpcy5lbC5pZCA9IGBzZWN0aW9uLSR7KGkgKyAxKX1gO1xuICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZChDTEFTU0VTLlNMSURFKTtcblxuICAgIC8vIEhpZGUgc2xpZGVzIGJ5IGRlZmF1bHRcbiAgICB0aGlzLmhpZGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlcyB0aGUgbm9kZSBhbmQgcmVtb3ZlcyB0aGUgY2xhc3MgdGhhdCBtYWtlcyBpdCBcImFjdGl2ZVwiLlxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICBET00uaGlkZSh0aGlzLmVsKTtcbiAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NFUy5DVVJSRU5UKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaG93cyB0aGUgbm9kZSBhbmQgYWRkcyB0aGUgY2xhc3MgdGhhdCBtYWtlcyBpdCBcImFjdGl2ZVwiLlxuICAgKi9cbiAgc2hvdygpIHtcbiAgICBET00uc2hvdyh0aGlzLmVsKTtcbiAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoQ0xBU1NFUy5DVVJSRU5UKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyB0aGUgc2VjdGlvbiB0byB0aGUgYm90dG9tIG9mIHRoZSBzZWN0aW9uJ3MgbGlzdC5cbiAgICogQGZpcmVzIFNsaWRlI2RvbTpsZWF2ZVxuICAgKiBAZmlyZXMgU2xpZGUjZG9tOmVudGVyXG4gICAqL1xuICBtb3ZlQWZ0ZXJMYXN0KCkge1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLnBhcmVudC5jaGlsZE5vZGVzW3RoaXMucGFyZW50LmNoaWxkRWxlbWVudENvdW50IC0gMV07XG5cbiAgICB0aGlzLmZpcmVfKEV2ZW50cy5MRUFWRSk7XG4gICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMuZWwsIGxhc3QubmV4dFNpYmxpbmcpO1xuICAgIHRoaXMuZmlyZV8oRXZlbnRzLkVOVEVSKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyB0aGUgc2VjdGlvbiB0byB0aGUgdG9wIG9mIHRoZSBzZWN0aW9uJ3MgbGlzdC5cbiAgICogQGZpcmVzIFNsaWRlI2RvbTpsZWF2ZVxuICAgKiBAZmlyZXMgU2xpZGUjZG9tOmVudGVyXG4gICAqL1xuICBtb3ZlQmVmb3JlRmlyc3QoKSB7XG4gICAgY29uc3QgZmlyc3QgPSB0aGlzLnBhcmVudC5jaGlsZE5vZGVzWzBdO1xuXG4gICAgdGhpcy5maXJlXyhFdmVudHMuTEVBVkUpO1xuICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLmVsLCBmaXJzdCk7XG4gICAgdGhpcy5maXJlXyhFdmVudHMuRU5URVIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIGFuIGVuYWJsZSBldmVudC5cbiAgICogQGZpcmVzIFNsaWRlI3NsaWRlOmVuYWJsZVxuICAgKi9cbiAgZW5hYmxlKCkge1xuICAgIHRoaXMuZmlyZV8oRXZlbnRzLkVOQUJMRSk7XG4gIH1cblxuICAvKipcbiAgICogRmlyZXMgYSBkaXNhYmxlIGV2ZW50LlxuICAgKiBAZmlyZXMgU2xpZGUjc2xpZGU6ZGlzYWJsZVxuICAgKi9cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLmZpcmVfKEV2ZW50cy5ESVNBQkxFKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyBhbiBldmVudCBwYXNzaW5nIHRoZSBzbGlkZSBpbnN0YW5jZSBvbiB0aGUgZGV0YWlsLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBldmVudCB0byBmaXJlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZmlyZV8obmFtZSkge1xuICAgIERPTS5maXJlRXZlbnQodGhpcy5lbCwgbmFtZSwge1xuICAgICAgc2xpZGU6IHRoaXNcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhbiBlbGVtZW50IGlzIGEgdmFsaWQgY2FuZGlkYXRlIHRvIGJlIGEgc2xpZGUgYnkgZW5zdXJpbmdcbiAgICogaXQncyBhIFwic2VjdGlvblwiIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgRWxlbWVudCB0byBiZSBjaGVja2VkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIGlzIGNhbmRpZGF0ZSBvciBub3QuXG4gICAqL1xuICBzdGF0aWMgaXNDYW5kaWRhdGUoZWwpIHtcbiAgICByZXR1cm4gZWwubm9kZVR5cGUgPT09IDEgJiYgZWwudGFnTmFtZSA9PT0gJ1NFQ1RJT04nO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNlY3Rpb24gZWxlbWVudCBmcm9tIGFuIGlubmVyIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICogQHJldHVybiB7e3NlY3Rpb246ID9Ob2RlLCBpOiA/bnVtYmVyfX0gQSBtYXAgd2l0aCB0aGUgc2VjdGlvbiBhbmQgdGhlXG4gICAqIHBvc2l0aW9uIG9mIHRoZSBzZWN0aW9uLlxuICAgKi9cbiAgc3RhdGljIGdldFNlY3Rpb25Gcm9tRWwoZWwpIHtcbiAgICBsZXQgcGFyZW50ID0gZWw7XG4gICAgbGV0IHNlY3Rpb24gPSBudWxsO1xuICAgIGxldCBpID0gbnVsbDtcblxuICAgIHdoaWxlIChwYXJlbnQucGFyZW50RWxlbWVudCAmJlxuICAgICAgICAgICFwYXJlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTRVMuU0xJREUpKSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudDtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU0VTLlNMSURFKSkge1xuICAgICAgc2VjdGlvbiA9IHBhcmVudDtcbiAgICAgIGkgPSBwYXJzZUludChzZWN0aW9uLmlkLnJlcGxhY2UoJ3NlY3Rpb24tJywgJycpLCAxMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtzZWN0aW9uLCBpfTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBTbGlkZSBhcyBkZWZhdWx0LFxuICBFdmVudHNcbn07XG4iLCJpbXBvcnQgRE9NIGZyb20gJy4uL3V0aWxzL2RvbSc7XG5pbXBvcnQge2RlZmF1bHQgYXMgU2xpZGUsIEV2ZW50cyBhcyBTbGlkZUV2ZW50c30gZnJvbSAnLi4vbW9kdWxlcy9zbGlkZSc7XG5cbi8qKlxuICogVmlkZW8gcGx1Z2luLiBWaWRlbyBwbHVnaW4gdGhhdCBhbGxvd3MgdG8gYXV0b3BsYXkgdmlkZW9zIG9uY2UgdGhlIHNsaWRlIGdldHNcbiAqIGFjdGl2ZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlkZW8ge1xuICAvKipcbiAgICogQHBhcmFtIHtXZWJTbGlkZXN9IHdzSW5zdGFuY2UgVGhlIFdlYlNsaWRlcyBpbnN0YW5jZS5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3c0luc3RhbmNlKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1dlYlNsaWRlc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMud3NfID0gd3NJbnN0YW5jZTtcblxuICAgIGNvbnN0IHZpZGVvcyA9IERPTS50b0FycmF5KHRoaXMud3NfLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ3ZpZGVvJykpO1xuXG4gICAgaWYgKHZpZGVvcy5sZW5ndGgpIHtcbiAgICAgIHZpZGVvcy5mb3JFYWNoKHZpZGVvID0+IHtcbiAgICAgICAgaWYgKCF2aWRlby5oYXNBdHRyaWJ1dGUoJ2F1dG9wbGF5JykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2aWRlby5yZW1vdmVBdHRyaWJ1dGUoJ2F1dG9wbGF5Jyk7XG4gICAgICAgIHZpZGVvLnBhdXNlKCk7XG4gICAgICAgIHZpZGVvLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgY29uc3Qge2l9ID0gU2xpZGUuZ2V0U2VjdGlvbkZyb21FbCh2aWRlbyk7XG4gICAgICAgIGNvbnN0IHNsaWRlID0gd3NJbnN0YW5jZS5zbGlkZXNbaSAtIDFdO1xuXG4gICAgICAgIHNsaWRlLnZpZGVvID0gdmlkZW87XG5cbiAgICAgICAgc2xpZGUuZWwuYWRkRXZlbnRMaXN0ZW5lcihTbGlkZUV2ZW50cy5FTkFCTEUsIFZpZGVvLm9uU2VjdGlvbkVuYWJsZWQpO1xuICAgICAgICBzbGlkZS5lbC5hZGRFdmVudExpc3RlbmVyKFNsaWRlRXZlbnRzLkRJU0FCTEUsIFZpZGVvLm9uU2VjdGlvbkRpc2FibGVkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBTZWN0aW9uIGVuYWJsZSBob29rLiBXaWxsIHBsYXkgdGhlIHZpZGVvLlxuICAgKiBAcGFyYW0ge0N1c3RvbUV2ZW50fSBldmVudFxuICAgKi9cbiAgc3RhdGljIG9uU2VjdGlvbkVuYWJsZWQoZXZlbnQpIHtcbiAgICBldmVudC5kZXRhaWwuc2xpZGUudmlkZW8ucGxheSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9uIFNlY3Rpb24gZW5hYmxlIGhvb2suIFdpbGwgcGF1c2UgdGhlIHZpZGVvLlxuICAgKiBAcGFyYW0ge0N1c3RvbUV2ZW50fSBldmVudFxuICAgKi9cbiAgc3RhdGljIG9uU2VjdGlvbkRpc2FibGVkKGV2ZW50KSB7XG4gICAgZXZlbnQuZGV0YWlsLnNsaWRlLnZpZGVvLnBhdXNlKCk7XG4gIH1cbn1cbiIsIi8qIGdsb2JhbCBZVCAqL1xuaW1wb3J0IERPTSBmcm9tICcuLi91dGlscy9kb20nO1xuaW1wb3J0IHtkZWZhdWx0IGFzIFNsaWRlLCBFdmVudHMgYXMgU2xpZGVFdmVudHN9IGZyb20gJy4uL21vZHVsZXMvc2xpZGUnO1xuXG4vKipcbiAqIFBsYXllciB3cmFwcGVyIGFyb3VuZCB0aGUgWVQgcGxheWVyLiBUaGlzIGlzIG1vc3RseSB0byBnZXQgYXJvdW5kIHRoZSBldmVudFxuICogaW4gd2hpY2ggd2UgbmVlZCB0byBwbGF5IGEgdmlkZW8gd2hpY2ggcGxheWVyIGlzbid0IHJlYWR5IHlldC5cbiAqL1xuY2xhc3MgUGxheWVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsKSB7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgUGxheWVyIGlzIHJlYWR5IG9yIG5vdC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogUmVhZHkgY2FsbGJhY2suXG4gICAgICogQHR5cGUgez9mdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLm9uUmVhZHlDYiA9IG51bGw7XG4gICAgLyoqXG4gICAgICogU2xpZGUgZWxlbWVudCBpbiB3aGljaCB0aGUgdmlkZW8gaXMgbG9jYXRlZC5cbiAgICAgKiBAdHlwZSB7Tm9kZX1cbiAgICAgKi9cbiAgICB0aGlzLnNsaWRlID0gU2xpZGUuZ2V0U2VjdGlvbkZyb21FbChlbCkuc2VjdGlvbjtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0IHNob3VsZCBhdXRvcGxheSBvbiBsb2FkIG9yIG5vdC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmF1dG9wbGF5ID0gdHlwZW9mIGVsLmRhdGFzZXQuYXV0b3BsYXkgIT09ICd1bmRlZmluZWQnO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHZpZGVvIHNob3VsZCBiZSBtdXRlZCBvciBub3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc011dGVkID0gdHlwZW9mIGVsLmRhdGFzZXQubXV0ZSAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25zIHdpdGggd2hpY2ggdGhlIHBsYXllciBpcyBjcmVhdGVkLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgdmlkZW9JZDogZWwuZGF0YXNldC55b3V0dWJlSWQsXG4gICAgICBwbGF5ZXJWYXJzOiB0aGlzLmdldFBsYXllclZhcnMoZWwpLFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIG9uUmVhZHk6IHRoaXMub25QbGF5ZXJSZWFkeS5iaW5kKHRoaXMpXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpZnJhbWUgaW4gd2hpY2ggdGhlIHZpZGVvIGlzIGxvYWRlZC5cbiAgICAgKiBAdHlwZSB7RWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmVsID0gZWw7XG4gICAgLyoqXG4gICAgICogVGltZW91dCBpZC5cbiAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuXG4gICAgdGhpcy5jcmVhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgaWZyYW1lLiBTYXZlcyB0aGUgY3VycmVudCB0aW1lIGluIGNhc2UgaXQgZ2V0cyByZXN0b3JlZC5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jdXJyZW50VGltZSA9IHRoaXMucGxheWVyLmdldEN1cnJlbnRUaW1lKCk7XG4gICAgdGhpcy5wbGF5ZXIuZGVzdHJveSgpO1xuICAgIHRoaXMucGxheWVyID0gbnVsbDtcbiAgICB0aGlzLmVsID0gdGhpcy5zbGlkZS5xdWVyeVNlbGVjdG9yKCdbZGF0YS15b3V0dWJlXScpO1xuICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBwbGF5ZXIuXG4gICAqL1xuICBjcmVhdGUoKSB7XG4gICAgdGhpcy5wbGF5ZXIgPSBuZXcgWVQuUGxheWVyKHRoaXMuZWwsIHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy5lbCA9IHRoaXMucGxheWVyLmdldElmcmFtZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBsYXllciByZWFkeSBjYWxsYmFjay4gV2lsbCBwbGF5IHRoZSB2aWRlbyBpZiBpdCB3YXMgaW50ZW5kZWQgdG8gYmUgcGxheWVkXG4gICAqIGFuZCB3aWxsIGFsc28gY2FsbCBhbnkgcGVuZGluZyBjYWxsYmFja3MuXG4gICAqL1xuICBvblBsYXllclJlYWR5KCkge1xuICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuXG4gICAgLy8gUmVzdG9yaW5nIHRoZSBjdXJyZW50IHRpbWUgaWYgc2F2ZWRcbiAgICBpZiAodGhpcy5jdXJyZW50VGltZSkge1xuICAgICAgdGhpcy5wbGF5ZXIuc2Vla1RvKHRoaXMuY3VycmVudFRpbWUsIHRydWUpO1xuICAgICAgdGhpcy5wbGF5ZXIucGF1c2VWaWRlbygpO1xuICAgICAgdGhpcy5jdXJyZW50VGltZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGltZW91dCAmJiB0aGlzLnBsYXllci5nZXRQbGF5ZXJTdGF0ZSgpICE9PSAxKSB7XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vblJlYWR5Q2IpIHtcbiAgICAgIHRoaXMub25SZWFkeUNiKCk7XG4gICAgICB0aGlzLm9uUmVhZHlDYiA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBsYXlzIHRoZSB2aWRlby5cbiAgICovXG4gIHBsYXkoKSB7XG4gICAgaWYgKHRoaXMucmVhZHkpIHtcbiAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICAgICAgfSwgMTAwMCk7XG5cbiAgICAgIGlmICh0aGlzLmlzTXV0ZWQpIHtcbiAgICAgICAgdGhpcy5wbGF5ZXIubXV0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wbGF5ZXIudW5NdXRlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGxheWVyLnBsYXlWaWRlbygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uUmVhZHlDYiA9IHRoaXMucGxheTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGF1c2UgcGxheWluZyB0aGUgdmlkZW8gaWYgaXQncyBhbHJlYWR5IHBsYXlpbmcuXG4gICAqL1xuICBwYXVzZSgpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXIgJiZcbiAgICAgICAgdGhpcy5wbGF5ZXIucGF1c2VWaWRlbyAmJlxuICAgICAgICB0aGlzLnBsYXllci5nZXRQbGF5ZXJTdGF0ZSgpID09PSAxKSB7XG4gICAgICB0aGlzLnBsYXllci5wYXVzZVZpZGVvKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgZWxlbWVudCB0byBoYXZlIHRoZSBwcm9wZXIgdmFyaWFibGVzLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHJldHVybiB7T2JqZWN0fSBQbGF5ZXIgdmFyaWFibGVzLlxuICAgKi9cbiAgZ2V0UGxheWVyVmFycyhlbGVtZW50KSB7XG4gICAgY29uc3QgdmFycyA9IHtcbiAgICAgIG1vZGVzdGJyYW5kaW5nOiAxLFxuICAgICAgcmVsOiAwLFxuICAgICAgb3JpZ2luOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnNsaWRlLmNsYXNzTGlzdC5jb250YWlucygnZnVsbHNjcmVlbicpKSB7XG4gICAgICAvLyBEaXNhYmxpbmcga2V5Ym9hcmQgaW50ZXJhY3Rpb24gZm9yIGZ1bGxzY3JlZW52aWRlb3NcbiAgICAgIHZhcnMuZGlzYWJsZWtiID0gMTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGVsZW1lbnQuZGF0YXNldC5ub0NvbnRyb2xzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFycy5jb250cm9scyA9IDA7XG4gICAgICB2YXJzLnNob3dpbmZvID0gMDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGVsZW1lbnQuZGF0YXNldC5sb29wICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFycy5sb29wID0gMTtcbiAgICAgIHZhcnMucGxheWxpc3QgPSBlbGVtZW50LmRhdGFzZXQueW91dHViZUlkO1xuICAgIH1cblxuICAgIHJldHVybiB2YXJzO1xuICB9XG59XG5cbi8qKlxuICogVmlkZW8gcGx1Z2luLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBZb3VUdWJlIHtcbiAgLyoqXG4gICAqIEdyaWQgcGx1Z2luIHRoYXQgc2hvd3MgYSBncmlkIG9uIHRvcCBvZiB0aGUgV2ViU2xpZGVzIGZvciBlYXN5IHByb3RvdHlwaW5nLlxuICAgKiBAcGFyYW0ge1dlYlNsaWRlc30gd3NJbnN0YW5jZSBUaGUgV2ViU2xpZGVzIGluc3RhbmNlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3c0luc3RhbmNlKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1dlYlNsaWRlc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMud3NfID0gd3NJbnN0YW5jZTtcblxuICAgIHRoaXMudmlkZW9zID0gRE9NLnRvQXJyYXkodGhpcy53c18uZWwucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEteW91dHViZV0nKSk7XG5cbiAgICBpZiAodGhpcy52aWRlb3MubGVuZ3RoKSB7XG4gICAgICB0aGlzLmluamVjdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPbmNlIHRoZSBZb3VUdWJlIEFQSSBpcyByZWFkeSB0aGlzIGdldHMgY2FsbGVkIHNvIHdlIGNhbiBzdGFydCB0aGUgdmlkZW9zLlxuICAgKi9cbiAgb25ZVFJlYWR5KCkge1xuICAgIHRoaXMudmlkZW9zLmZvckVhY2godmlkZW8gPT4ge1xuICAgICAgY29uc3QgcGxheWVyID0gbmV3IFBsYXllcih2aWRlbyk7XG5cbiAgICAgIGlmICh0eXBlb2YgdmlkZW8uZGF0YXNldC5hdXRvcGxheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3Qge2l9ID0gU2xpZGUuZ2V0U2VjdGlvbkZyb21FbChwbGF5ZXIuZWwpO1xuICAgICAgICBjb25zdCBzbGlkZSA9IHRoaXMud3NfLnNsaWRlc1tpIC0gMV07XG5cbiAgICAgICAgc2xpZGUucGxheWVyID0gcGxheWVyO1xuXG4gICAgICAgIHNsaWRlLmVsLmFkZEV2ZW50TGlzdGVuZXIoU2xpZGVFdmVudHMuRU5BQkxFLCBZb3VUdWJlLm9uU2xpZGVFdmVudCk7XG4gICAgICAgIHNsaWRlLmVsLmFkZEV2ZW50TGlzdGVuZXIoU2xpZGVFdmVudHMuRElTQUJMRSwgWW91VHViZS5vblNsaWRlRXZlbnQpO1xuICAgICAgICBzbGlkZS5lbC5hZGRFdmVudExpc3RlbmVyKFNsaWRlRXZlbnRzLkVOVEVSLCBZb3VUdWJlLm9uU2xpZGVFdmVudCk7XG4gICAgICAgIHNsaWRlLmVsLmFkZEV2ZW50TGlzdGVuZXIoU2xpZGVFdmVudHMuTEVBVkUsIFlvdVR1YmUub25TbGlkZUV2ZW50KTtcblxuICAgICAgICBpZiAodGhpcy53c18uY3VycmVudFNsaWRlXyA9PT0gc2xpZGUpIHtcbiAgICAgICAgICBZb3VUdWJlLm9uU2VjdGlvbkVuYWJsZWQoc2xpZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW5qZWN0cyB0aGUgWW91VHViZSBpRnJhbWUgQVBJIGludG8gdGhlIHBhZ2UuXG4gICAqL1xuICBpbmplY3QoKSB7XG4gICAgd2luZG93Lm9uWW91VHViZUlmcmFtZUFQSVJlYWR5ID0gdGhpcy5vbllUUmVhZHkuYmluZCh0aGlzKTtcbiAgICBjb25zdCB0YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICB0YWcuc3JjID0gYGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL2lmcmFtZV9hcGlgO1xuICAgIGNvbnN0IGZpcnN0U2NyaXB0VGFnID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuICAgIGZpcnN0U2NyaXB0VGFnLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRhZywgZmlyc3RTY3JpcHRUYWcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWN0cyB0byBhbnkgZXZlbnQgb24gdGhlIHNsaWRlLlxuICAgKiBAcGFyYW0ge0N1c3RvbUV2ZW50fSBldmVudFxuICAgKi9cbiAgc3RhdGljIG9uU2xpZGVFdmVudChldmVudCkge1xuICAgIGNvbnN0IHNsaWRlID0gZXZlbnQuZGV0YWlsLnNsaWRlO1xuXG4gICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICBjYXNlIFNsaWRlRXZlbnRzLkVOQUJMRTpcbiAgICAgICAgWW91VHViZS5vblNlY3Rpb25FbmFibGVkKHNsaWRlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNsaWRlRXZlbnRzLkRJU0FCTEU6XG4gICAgICAgIFlvdVR1YmUub25TZWN0aW9uRGlzYWJsZWQoc2xpZGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU2xpZGVFdmVudHMuTEVBVkU6XG4gICAgICAgIHNsaWRlLnBsYXllci5kZXN0cm95KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTbGlkZUV2ZW50cy5FTlRFUjpcbiAgICAgICAgc2xpZGUucGxheWVyLmNyZWF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT24gU2VjdGlvbiBlbmFibGUgaG9vay4gV2lsbCBwbGF5IHRoZSB2aWRlby5cbiAgICogQHBhcmFtIHtTbGlkZX0gc2xpZGVcbiAgICovXG4gIHN0YXRpYyBvblNlY3Rpb25FbmFibGVkKHNsaWRlKSB7XG4gICAgaWYgKHNsaWRlLnBsYXllci5hdXRvcGxheSkge1xuICAgICAgc2xpZGUucGxheWVyLnBsYXkoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT24gU2VjdGlvbiBlbmFibGUgaG9vay4gV2lsbCBwYXVzZSB0aGUgdmlkZW8uXG4gICAqIEBwYXJhbSB7U2xpZGV9IHNsaWRlXG4gICAqL1xuICBzdGF0aWMgb25TZWN0aW9uRGlzYWJsZWQoc2xpZGUpIHtcbiAgICBzbGlkZS5wbGF5ZXIucGF1c2UoKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBTd2luZyBlYXNpbmcgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gcCBUaGUgcGVyY2VudGFnZSBvZiB0aW1lIHRoYXQgaGFzIHBhc3NlZC5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gc3dpbmcocCkge1xuICByZXR1cm4gMC41IC0gTWF0aC5jb3MocCAqIE1hdGguUEkpIC8gMjtcbn1cblxuZXhwb3J0IGRlZmF1bHQge3N3aW5nfTtcbiIsImltcG9ydCBFYXNpbmdzIGZyb20gJy4vZWFzaW5nJztcblxubGV0IFNDUk9MTEFCTEVfQ09OVEFJTkVSID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dlYnNsaWRlcycpO1xuXG4vKipcbiAqIFNtb290aGx5IHNjcm9sbHMgdG8gYSBnaXZlbiBZIHBvc2l0aW9uIHVzaW5nIEVhc2luZy5Td2luZy4gSXQnbGwgcnVuIGFcbiAqIGNhbGxiYWNrIHVwb24gZmluaXNoaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgT2Zmc2V0IG9mIHRoZSBwYWdlIHRvIHNjcm9sbCB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiBEdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uLiA1MDBtcyBieSBkZWZhdWx0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCB1cG9uIGNvbXBsZXRpb24uXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgVGhlIEhUTUwgZWxlbWVudCB3aGVyZSB0byBzY3JvbGxcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2Nyb2xsVG8oXG4gICAgeSwgZHVyYXRpb24gPSA1MDAsIGNiID0gKCkgPT4ge30sIGNvbnRhaW5lciA9IG51bGwpIHtcbiAgU0NST0xMQUJMRV9DT05UQUlORVIgPSBjb250YWluZXIgP1xuICAgICAgY29udGFpbmVyIDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dlYnNsaWRlcycpO1xuXG4gIGNvbnN0IGRlbHRhID0geSAtIFNDUk9MTEFCTEVfQ09OVEFJTkVSLnNjcm9sbFRvcDtcbiAgY29uc3Qgc3RhcnRMb2NhdGlvbiA9IFNDUk9MTEFCTEVfQ09OVEFJTkVSLnNjcm9sbFRvcDtcbiAgY29uc3QgaW5jcmVtZW50ID0gMTY7XG5cbiAgaWYgKCFkdXJhdGlvbikge1xuICAgIFNDUk9MTEFCTEVfQ09OVEFJTkVSLnNjcm9sbFRvcCA9IHk7XG4gICAgY2IoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBhbmltYXRlU2Nyb2xsID0gZWxhcHNlZFRpbWUgPT4ge1xuICAgIGVsYXBzZWRUaW1lICs9IGluY3JlbWVudDtcbiAgICBjb25zdCBwZXJjZW50ID0gTWF0aC5taW4oMSwgZWxhcHNlZFRpbWUgLyBkdXJhdGlvbik7XG4gICAgY29uc3QgZWFzaW5nUCA9IEVhc2luZ3Muc3dpbmcoXG4gICAgICBwZXJjZW50LFxuICAgICAgZWxhcHNlZFRpbWUgKiBwZXJjZW50LFxuICAgICAgeSxcbiAgICAgIGRlbHRhLFxuICAgICAgZHVyYXRpb24pO1xuXG4gICAgU0NST0xMQUJMRV9DT05UQUlORVIuc2Nyb2xsVG9wID0gTWF0aC5mbG9vcihzdGFydExvY2F0aW9uICtcbiAgICAgICAgKGVhc2luZ1AgKiBkZWx0YSkpO1xuXG4gICAgaWYgKGVsYXBzZWRUaW1lIDwgZHVyYXRpb24pIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gYW5pbWF0ZVNjcm9sbChlbGFwc2VkVGltZSksIGluY3JlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9O1xuXG4gIGFuaW1hdGVTY3JvbGwoMCk7XG59XG4iLCJpbXBvcnQgRE9NIGZyb20gJy4uL3V0aWxzL2RvbSc7XG5pbXBvcnQgS2V5cyBmcm9tICcuLi91dGlscy9rZXlzJztcbmltcG9ydCBzY3JvbGxUbyBmcm9tICcuLi91dGlscy9zY3JvbGwtdG8nO1xuaW1wb3J0IFNsaWRlIGZyb20gJy4uL21vZHVsZXMvc2xpZGUnO1xuXG5jb25zdCBDTEFTU0VTID0ge1xuICBaT09NOiAnZ3JpZCcsXG4gIERJVjogJ2NvbHVtbicsXG4gIFdSQVA6ICd3cmFwLXpvb20nLFxuICBXUkFQX0NPTlRBSU5FUjogJ3dyYXAnLFxuICBDVVJSRU5UOiAnY3VycmVudCcsXG4gIFNMSURFOiAnc2xpZGUnLFxuICBaT09NX0VOQUJMRUQ6ICd3cy1yZWFkeS16b29tJ1xufTtcblxuY29uc3QgSUQgPSAnd2Vic2xpZGVzLXpvb21lZCc7XG5cbi8qKlxuICogWm9vbSBwbHVnaW4uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFpvb20ge1xuICAvKipcbiAgICogQHBhcmFtIHtXZWJTbGlkZXN9IHdzSW5zdGFuY2UgVGhlIFdlYlNsaWRlcyBpbnN0YW5jZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdzSW5zdGFuY2UpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7V2ViU2xpZGVzfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy53c18gPSB3c0luc3RhbmNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1dlYlNsaWRlc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuendzXyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmlzWm9vbWVkXyA9IGZhbHNlO1xuXG4gICAgdGhpcy5wcmVCdWlsZFpvb21fKCk7XG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vbktleURvd24uYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogT24ga2V5IGRvd24gaGFuZGxlci4gV2lsbCBkZWNpZGUgaWYgWm9vbSBpbiBvciBvdXRcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgS2V5IGRvd24gZXZlbnQuXG4gICAqL1xuICBvbktleURvd24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuaXNab29tZWRfICYmIEtleXMuTUlOVVMuc29tZShrZXkgPT4ga2V5ID09PSBldmVudC53aGljaCkpIHtcbiAgICAgIHRoaXMuem9vbUluKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzWm9vbWVkXyAmJlxuICAgICAgKEtleXMuUExVUy5zb21lKGtleSA9PiBrZXkgPT09IGV2ZW50LndoaWNoKSB8fFxuICAgICAgICBldmVudC53aGljaCA9PT0gS2V5cy5FU0NBUEUpKSB7XG4gICAgICB0aGlzLnpvb21PdXQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJlcGFyZSB6b29tIHN0cnVjdHVyZSwgc2NhbGVzIHRoZSBzbGlkZXMgYW5kIHVzZXMgYSBncmlkIGxheW91dFxuICAgKiB0byBzaG93IHRoZW0uXG4gICAqL1xuICBwcmVCdWlsZFpvb21fKCkge1xuICAgIC8vIENsb25lICN3ZWJzbGlkZXMgZWxlbWVudFxuICAgIHRoaXMuendzXy5lbCA9IHRoaXMud3NfLmVsLmNsb25lTm9kZSgpO1xuICAgIHRoaXMuendzXy5lbC5pZCA9IElEO1xuICAgIHRoaXMuendzXy53cmFwID0gRE9NLmNyZWF0ZU5vZGUoJ2RpdicpO1xuICAgIHRoaXMuendzXy53cmFwLmNsYXNzTmFtZSA9IENMQVNTRVMuV1JBUF9DT05UQUlORVI7XG4gICAgdGhpcy56d3NfLmVsLmFwcGVuZENoaWxkKHRoaXMuendzXy53cmFwKTtcbiAgICB0aGlzLnp3c18uZ3JpZCA9IERPTS5jcmVhdGVOb2RlKCdkaXYnKTtcbiAgICB0aGlzLnp3c18uZ3JpZC5jbGFzc05hbWUgPSBDTEFTU0VTLlpPT007XG4gICAgdGhpcy56d3NfLndyYXAuYXBwZW5kQ2hpbGQodGhpcy56d3NfLmdyaWQpO1xuXG4gICAgdGhpcy56d3NfLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy50b2dnbGVab29tKCkpO1xuXG4gICAgLy8gQ2xvbmUgdGhlIHNsaWRlc1xuICAgIHRoaXMuendzXy5zbGlkZXMgPSBbXS5tYXAuY2FsbCh0aGlzLndzXy5zbGlkZXMsXG4gICAgICAgIChzbGlkZSwgaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHNfID0gc2xpZGUuZWwuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgIHRoaXMuendzXy5ncmlkLmFwcGVuZENoaWxkKHNfKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFNsaWRlKHNfLCBpKTtcbiAgICAgICAgfSk7XG5cbiAgICB0aGlzLmRpc2FibGUoKTtcbiAgICBET00uYWZ0ZXIodGhpcy56d3NfLmVsLCB0aGlzLndzXy5lbCk7XG5cbiAgICAvLyBDcmVhdGVzIHRoZSBjb250YWluZXIgZm9yIGVhY2ggc2xpZGVcbiAgICB0aGlzLnp3c18uc2xpZGVzLmZvckVhY2goZWxlbSA9PiB0aGlzLmNyZWF0ZVNsaWRlQmxvY2tfKGVsZW0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgYmxvY2sgc3RydWN0dXJlIGFyb3VuZCB0aGUgc2xpZGUuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbSBzbGlkZSBlbGVtZW50LlxuICAgKi9cbiAgY3JlYXRlU2xpZGVCbG9ja18oZWxlbSkge1xuICAgIC8vIFdyYXBzIHRoZSBzbGlkZSBhcm91bmQgYSBjb250YWluZXJcbiAgICBjb25zdCB3cmFwID0gRE9NLndyYXAoZWxlbS5lbCwgJ2RpdicpO1xuICAgIHdyYXAuY2xhc3NOYW1lID0gQ0xBU1NFUy5XUkFQO1xuICAgIHdyYXAuc2V0QXR0cmlidXRlKCdpZCcsIGB6b29tZWQtJHtlbGVtLmVsLmdldEF0dHJpYnV0ZSgnaWQnKX1gKTtcblxuICAgIC8vIFNsaWRlIGNvbnRhaW5lciwgbmVlZCBkdWUgdG8gZmxleGJveCBzdHlsZXNcbiAgICBjb25zdCBkaXYgPSBET00ud3JhcCh3cmFwLCAnZGl2Jyk7XG4gICAgZGl2LmNsYXNzTmFtZSA9IENMQVNTRVMuRElWO1xuXG4gICAgLy8gQWRkaW5nIHNvbWUgbGF5ZXIgZm9yIGNvbnRyb2xsaW5nIGNsaWNrIGV2ZW50c1xuICAgIGNvbnN0IGRpdkxheWVyID0gRE9NLmNyZWF0ZU5vZGUoJ2RpdicpO1xuICAgIGRpdkxheWVyLmNsYXNzTmFtZSA9ICd6b29tLWxheWVyJztcbiAgICBkaXZMYXllci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHRoaXMuem9vbU91dCgpO1xuICAgICAgdGhpcy53c18uZ29Ub1NsaWRlKGVsZW0uaSk7XG4gICAgfSk7XG4gICAgd3JhcC5hcHBlbmRDaGlsZChkaXZMYXllcik7XG5cbiAgICAvLyBTbGlkZSBudW1iZXJcbiAgICBjb25zdCBzbGlkZU51bWJlciA9IERPTS5jcmVhdGVOb2RlKCdwJywgJycsIGAke2VsZW0uaSArIDF9YCk7XG4gICAgc2xpZGVOdW1iZXIuY2xhc3NOYW1lID0gJ3RleHQtc2xpZGUtbnVtYmVyJztcbiAgICBkaXYuYXBwZW5kQ2hpbGQoc2xpZGVOdW1iZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgem9vbS5cbiAgICovXG4gIHRvZ2dsZVpvb20oKSB7XG4gICAgaWYgKHRoaXMuaXNab29tZWRfKSB7XG4gICAgICB0aGlzLnpvb21PdXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy56b29tSW4oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogWm9vbSBJbiB0aGUgc2xpZGVyLCBzY2FsZXMgdGhlIHNsaWRlcyBhbmQgdXNlcyBhIGdyaWQgbGF5b3V0IHRvIHNob3cgdGhlbS5cbiAgICovXG4gIHpvb21JbigpIHtcbiAgICBpZiAoIXRoaXMud3NfLm9wdGlvbnMuc2hvd0luZGV4KSByZXR1cm47XG4gICAgdGhpcy5lbmFibGUoKTtcbiAgICBjb25zdCBjdXJyZW50SWQgPSB0aGlzLndzXy5jdXJyZW50U2xpZGVfLmVsLmlkO1xuICAgIGNvbnN0IHpvb21lZEN1cnJlbnQgPSB0aGlzLnp3c18uZWxcbiAgICAgIC5xdWVyeVNlbGVjdG9yKGAuJHtDTEFTU0VTLldSQVB9LiR7Q0xBU1NFUy5DVVJSRU5UfWApO1xuXG4gICAgaWYgKHpvb21lZEN1cnJlbnQpIHtcbiAgICAgIHpvb21lZEN1cnJlbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU0VTLkNVUlJFTlQpO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdHVhbEN1cnJlbnQgPSB0aGlzLnp3c18uZWxcbiAgICAgIC5xdWVyeVNlbGVjdG9yKGAjem9vbWVkLSR7Y3VycmVudElkfWApO1xuICAgIGFjdHVhbEN1cnJlbnQuY2xhc3NMaXN0LmFkZChDTEFTU0VTLkNVUlJFTlQpO1xuXG4gICAgdGhpcy5pc1pvb21lZF8gPSB0cnVlO1xuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTRVMuWk9PTV9FTkFCTEVEKTtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy53c18uZGlzYWJsZSgpO1xuICAgICAgdGhpcy56d3NfLmVsLmNsYXNzTGlzdC5hZGQoJ2luJyk7XG4gICAgICBjb25zdCB3cmFwQ1NTID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy56d3NfLmdyaWQpO1xuICAgICAgY29uc3Qgc2Nyb2xsaW5nRWxlbWVudCA9IGRvY3VtZW50LmJvZHk7XG5cbiAgICAgIHNjcm9sbFRvKGFjdHVhbEN1cnJlbnQucGFyZW50Tm9kZS5vZmZzZXRUb3BcbiAgICAgICAgKyBET00ucGFyc2VTaXplKHdyYXBDU1MucGFkZGluZ1RvcCksIDUwLCAoKSA9PiB7fSwgc2Nyb2xsaW5nRWxlbWVudCk7XG4gICAgfSwgNTApO1xuICB9XG5cbiAgLyoqXG4gICAqIFpvb20gT3V0IHRoZSBzbGlkZXIsIHJlbW92ZSBzY2FsZSBmcm9tIHRoZSBzbGlkZXMuXG4gICAqL1xuICB6b29tT3V0KCkge1xuICAgIGlmICghdGhpcy53c18ub3B0aW9ucy5zaG93SW5kZXgpIHJldHVybjtcbiAgICB0aGlzLnp3c18uZWwuY2xhc3NMaXN0LnJlbW92ZSgnaW4nKTtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy53c18uZW5hYmxlKCk7XG4gICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICAgIHRoaXMuaXNab29tZWRfID0gZmFsc2U7XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU0VTLlpPT01fRU5BQkxFRCk7XG4gICAgfSwgNDAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlcyB0aGUgem9vbSBjb250YWluZXJcbiAgICovXG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy56d3NfLmVsLmNsYXNzTGlzdC5hZGQoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogU2hvd3MgdGhlIHpvb20gY29udGFpbmVyXG4gICAqL1xuICBlbmFibGUoKSB7XG4gICAgdGhpcy56d3NfLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ2Rpc2FibGVkJyk7XG4gIH1cbn1cbiIsImltcG9ydCBBdXRvU2xpZGUgZnJvbSAnLi9hdXRvc2xpZGUnO1xuaW1wb3J0IENsaWNrTmF2IGZyb20gJy4vY2xpY2stbmF2JztcbmltcG9ydCBHcmlkIGZyb20gJy4vZ3JpZCc7XG5pbXBvcnQgSGFzaCBmcm9tICcuL2hhc2gnO1xuaW1wb3J0IEtleWJvYXJkIGZyb20gJy4va2V5Ym9hcmQnO1xuaW1wb3J0IE5hdmlnYXRpb24gZnJvbSAnLi9uYXZpZ2F0aW9uJztcbmltcG9ydCBTY3JvbGwgZnJvbSAnLi9zY3JvbGwnO1xuaW1wb3J0IFRvdWNoIGZyb20gJy4vdG91Y2gnO1xuaW1wb3J0IFZpZGVvIGZyb20gJy4vdmlkZW8nO1xuaW1wb3J0IFlvdVR1YmUgZnJvbSAnLi95b3V0dWJlJztcbmltcG9ydCBab29tIGZyb20gJy4vem9vbSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgQXV0b1NsaWRlLFxuICBDbGlja05hdixcbiAgR3JpZCxcbiAgSGFzaCxcbiAgS2V5Ym9hcmQsXG4gIE5hdmlnYXRpb24sXG4gIFNjcm9sbCxcbiAgVG91Y2gsXG4gIFZpZGVvLFxuICBZb3VUdWJlLFxuICBab29tXG59O1xuIiwiaW1wb3J0IFBsdWdpbnMgZnJvbSAnLi4vcGx1Z2lucy9wbHVnaW5zJztcbmltcG9ydCBTbGlkZSBmcm9tICcuL3NsaWRlJztcbmltcG9ydCBET00gZnJvbSAnLi4vdXRpbHMvZG9tJztcbmltcG9ydCBzY3JvbGxUbyBmcm9tICcuLi91dGlscy9zY3JvbGwtdG8nO1xuXG5jb25zdCBDTEFTU0VTID0ge1xuICBWRVJUSUNBTDogJ3ZlcnRpY2FsJyxcbiAgUkVBRFk6ICd3cy1yZWFkeScsXG4gIERJU0FCTEVEOiAnZGlzYWJsZWQnXG59O1xuXG4vLyBEZWZhdWx0IHBsdWdpbnNcbmNvbnN0IFBMVUdJTlMgPSB7XG4gICdhdXRvc2xpZGUnOiBQbHVnaW5zLkF1dG9TbGlkZSxcbiAgJ2NsaWNrTmF2JzogUGx1Z2lucy5DbGlja05hdixcbiAgJ2dyaWQnOiBQbHVnaW5zLkdyaWQsXG4gICdoYXNoJzogUGx1Z2lucy5IYXNoLFxuICAna2V5Ym9hcmQnOiBQbHVnaW5zLktleWJvYXJkLFxuICAnbmF2JzogUGx1Z2lucy5OYXZpZ2F0aW9uLFxuICAnc2Nyb2xsJzogUGx1Z2lucy5TY3JvbGwsXG4gICd0b3VjaCc6IFBsdWdpbnMuVG91Y2gsXG4gICd2aWRlbyc6IFBsdWdpbnMuVmlkZW8sXG4gICd5b3V0dWJlJzogUGx1Z2lucy5Zb3VUdWJlLFxuICAnem9vbSc6IFBsdWdpbnMuWm9vbVxufTtcblxuXG4vKipcbiAqIFdlYlNsaWRlcyBtb2R1bGUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYlNsaWRlcyB7XG4gIC8qKlxuICAgKiBPcHRpb25zIGZvciBXZWJTbGlkZXNcbiAgICogQHBhcmFtIHtudW1iZXJ8Ym9vbGVhbn0gYXV0b3NsaWRlIElmIGEgbnVtYmVyIGlzIHByb3ZpZGVkLCBpdCB3aWxsIGFsbG93XG4gICAqIGF1dG9zbGlkaW5nIGJ5IHNhaWQgYW1vdW50IG9mIG1pbGxpc2Vjb25kcy5cbiAgICogQHBhcmFtIHtib29sZWFufSBjaGFuZ2VPbkNsaWNrIElmIHRydWUsIGl0IHdpbGwgYWxsb3dcbiAgICogY2xpY2tpbmcgb24gYW55IHBsYWNlIHRvIGNoYW5nZSB0aGUgc2xpZGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcCBXaGV0aGVyIHRvIGdvIHRvIGZpcnN0IHNsaWRlIGZyb20gbGFzdCBvbmUgb3Igbm90LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluV2hlZWxEZWx0YSBDb250cm9scyB0aGUgYW1vdW50IG9mIG5lZWRlZCBzY3JvbGwgdG9cbiAgICogdHJpZ2dlciBuYXZpZ2F0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG5hdmlnYXRlT25TY3JvbGwgV2hldGhlciBzY3JvbGwgY2FuIHRyaWdnZXIgbmF2aWdhdGlvbiBvclxuICAgKiBub3QuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxXYWl0IENvbnRyb2xzIHRoZSBhbW91bnQgb2YgdGltZSB0byB3YWl0IHRpbGxcbiAgICogbmF2aWdhdGlvbiBjYW4gb2NjdXIgYWdhaW4gd2l0aCBzY3JvbGwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzbGlkZU9mZnNldCBDb250cm9scyB0aGUgYW1vdW50IG9mIG5lZWRlZCB0b3VjaCBkZWx0YSB0b1xuICAgKiB0cmlnZ2VyIG5hdmlnYXRpb24uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvd0luZGV4IENvbnRyb2xzIGlmIHRoZSBpbmRleCBjYW4gYmUgc2hvd24uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYXV0b3NsaWRlID0gZmFsc2UsXG4gICAgY2hhbmdlT25DbGljayA9IGZhbHNlLFxuICAgIGxvb3AgPSB0cnVlLFxuICAgIG1pbldoZWVsRGVsdGEgPSA0MCxcbiAgICBuYXZpZ2F0ZU9uU2Nyb2xsID0gdHJ1ZSxcbiAgICBzY3JvbGxXYWl0ID0gNDUwLFxuICAgIHNsaWRlT2Zmc2V0ID0gNTAsXG4gICAgc2hvd0luZGV4ID0gdHJ1ZVxuICB9ID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBXZWJTbGlkZSBlbGVtZW50LlxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd2Vic2xpZGVzJyk7XG5cbiAgICBpZiAoIXRoaXMuZWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGRuXFwndCBmaW5kIHRoZSB3ZWJzbGlkZXMgY29udGFpbmVyIScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmluZyBmbGFnLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBTbGlkZSdzIGFycmF5LlxuICAgICAqIEB0eXBlIHs/QXJyYXk8U2xpZGU+fVxuICAgICAqL1xuICAgIHRoaXMuc2xpZGVzID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHNsaWRlJ3MgaW5kZXguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY3VycmVudFNsaWRlSV8gPSAtMTtcbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHNsaWRlIHJlZmVyZW5jZS5cbiAgICAgKiBAdHlwZSB7P1NsaWRlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50U2xpZGVfID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBNYXggc2xpZGUgaW5kZXguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubWF4U2xpZGVfID0gMDtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBsYXlvdXQgaXMgZ29pbmcgdG8gYmUgdmVydGljYWwgb3IgaG9yaXpvbnRhbC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzVmVydGljYWwgPSB0aGlzLmVsLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU0VTLlZFUlRJQ0FMKTtcbiAgICAvKipcbiAgICAgKiBQbHVnaW4ncyBkaWN0aW9uYXJ5LlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5wbHVnaW5zID0ge307XG4gICAgLyoqXG4gICAgICogT3B0aW9ucyBkaWN0aW9uYXJ5LlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgYXV0b3NsaWRlLFxuICAgICAgY2hhbmdlT25DbGljayxcbiAgICAgIGxvb3AsXG4gICAgICBtaW5XaGVlbERlbHRhLFxuICAgICAgbmF2aWdhdGVPblNjcm9sbCxcbiAgICAgIHNjcm9sbFdhaXQsXG4gICAgICBzbGlkZU9mZnNldCxcbiAgICAgIHNob3dJbmRleFxuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGlzYXRpb24gZmxhZy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmluaXRpYWxpc2VkID0gZmFsc2U7XG5cbiAgICAvLyBCb290c3RyYXBwaW5nXG4gICAgdGhpcy5yZW1vdmVDaGlsZHJlbl8oKTtcbiAgICB0aGlzLmdyYWJTbGlkZXNfKCk7XG4gICAgdGhpcy5jcmVhdGVQbHVnaW5zXygpO1xuICAgIHRoaXMuaW5pdFNsaWRlc18oKTtcbiAgICAvLyBGaW5pc2hlZFxuICAgIHRoaXMub25Jbml0XygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGNoaWxkcmVuIGVsZW1lbnRzIGluc2lkZSBvZiB0aGUgbWFpbiBjb250YWluZXIgdGhhdCBhcmUgbm90XG4gICAqIGVsaWdpYmxlIHRvIGJlIGEgU2xpZGUgRWxlbWVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlbW92ZUNoaWxkcmVuXygpIHtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMuZWwuY2hpbGROb2RlcztcbiAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblxuICAgICAgaWYgKCFTbGlkZS5pc0NhbmRpZGF0ZShub2RlKSkge1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFsbCB0aGUgcmVnaXN0ZXJlZCBwbHVnaW5zIGFuZCBzdG9yZSB0aGUgaW5zdGFuY2VzIGluc2lkZSBvZiB0aGVcbiAgICogdGhlIHdlYnNsaWRlIGluc3RhbmNlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlUGx1Z2luc18oKSB7XG4gICAgT2JqZWN0LmtleXMoUExVR0lOUykuZm9yRWFjaChwbHVnaW5OYW1lID0+IHtcbiAgICAgIGNvbnN0IFBsdWdpbkN0byA9IFBMVUdJTlNbcGx1Z2luTmFtZV07XG4gICAgICB0aGlzLnBsdWdpbnNbcGx1Z2luTmFtZV0gPSBuZXcgUGx1Z2luQ3RvKHRoaXMpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCBvbmNlIHRoZSBXZWJTbGlkZSBpbnN0YW5jZSBoYXMgZmluaXNoZWQgaW5pdGlhbGlzaW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZmlyZXMgV2ViU2xpZGUjd3M6aW5pdFxuICAgKi9cbiAgb25Jbml0XygpIHtcbiAgICB0aGlzLmluaXRpYWxpc2VkID0gdHJ1ZTtcbiAgICBET00uZmlyZUV2ZW50KHRoaXMuZWwsICd3czppbml0Jyk7XG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NFUy5SRUFEWSk7XG4gIH1cblxuICAvKipcbiAgICogR3JhYnMgdGhlIHNsaWRlcyBmcm9tIHRoZSBET00gYW5kIGNyZWF0ZXMgYWxsIHRoZSBTbGlkZXMgbW9kdWxlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdyYWJTbGlkZXNfKCkge1xuICAgIHRoaXMuc2xpZGVzID0gRE9NLnRvQXJyYXkodGhpcy5lbC5jaGlsZE5vZGVzKVxuICAgICAgICAubWFwKChzbGlkZSwgaSkgPT4gbmV3IFNsaWRlKHNsaWRlLCBpKSk7XG5cbiAgICB0aGlzLm1heFNsaWRlXyA9IHRoaXMuc2xpZGVzLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHb2VzIHRvIGEgZ2l2ZW4gc2xpZGUuXG4gICAqIEBwYXJhbSB7IW51bWJlcn0gc2xpZGVJIFRoZSBzbGlkZSBpbmRleC5cbiAgICogQHBhcmFtIHs/Ym9vbGVhbj19IGZvcndhcmQgV2hldGhlciB3ZSdyZSBmb3JjaW5nIG1vdmluZyBmb3J3YXJkL2JhY2t3YXJkcy5cbiAgICogVGhpcyBwYXJhbWV0ZXIgaXMgdXNlZCBvbmx5IGZyb20gdGhlIGdvTmV4dCwgZ29QcmV2IGZ1bmN0aW9ucyB0byBhZGp1c3QgdGhlXG4gICAqIHNjcm9sbCBhbmltYXRpb25zLlxuICAgKi9cbiAgZ29Ub1NsaWRlKHNsaWRlSSwgZm9yd2FyZCA9IG51bGwpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkSW5kZXhTbGlkZV8oc2xpZGVJKSAmJlxuICAgICAgICAhdGhpcy5pc01vdmluZyAmJlxuICAgICAgICB0aGlzLmN1cnJlbnRTbGlkZUlfICE9PSBzbGlkZUkpIHtcbiAgICAgIHRoaXMuaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgbGV0IGlzTW92aW5nRm9yd2FyZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoZm9yd2FyZCAhPT0gbnVsbCkge1xuICAgICAgICBpc01vdmluZ0ZvcndhcmQgPSBmb3J3YXJkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFNsaWRlSV8gPj0gMCkge1xuICAgICAgICAgIGlzTW92aW5nRm9yd2FyZCA9IHNsaWRlSSA+IHRoaXMuY3VycmVudFNsaWRlSV87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHRTbGlkZSA9IHRoaXMuc2xpZGVzW3NsaWRlSV07XG5cbiAgICAgIGlmICh0aGlzLmN1cnJlbnRTbGlkZV8gIT09IG51bGwgJiYgdGhpcy5pc1ZlcnRpY2FsICYmXG4gICAgICAgICghdGhpcy5wbHVnaW5zLnRvdWNoIHx8ICF0aGlzLnBsdWdpbnMudG91Y2guaXNFbmFibGVkKSkge1xuICAgICAgICB0aGlzLnNjcm9sbFRyYW5zaXRpb25Ub1NsaWRlXyhcbiAgICAgICAgICAgIGlzTW92aW5nRm9yd2FyZCwgbmV4dFNsaWRlLCB0aGlzLm9uU2xpZGVDaGFuZ2VfKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvblRvU2xpZGVfKFxuICAgICAgICAgICAgaXNNb3ZpbmdGb3J3YXJkLCBuZXh0U2xpZGUsIHRoaXMub25TbGlkZUNoYW5nZV8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2l0aW9ucyB0byBhIHNsaWRlLCBkb2luZyB0aGUgc2Nyb2xsIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc01vdmluZ0ZvcndhcmQgV2hldGhlciB3ZSdyZSBnb2luZyBmb3J3YXJkIG9yIGJhY2t3YXJkcy5cbiAgICogQHBhcmFtIHtTbGlkZX0gbmV4dFNsaWRlIE5leHQgc2xpZGUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGJlIGNhbGxlZCB1cG9uIGZpbmlzaGluZy4gVGhpcyBpcyBhblxuICAgKiBhc3luYyBmdW5jdGlvbiBzbyBpdCdsbCBoYXBwZW4gb25jZSB0aGUgc2Nyb2xsIGFuaW1hdGlvbiBmaW5pc2hlcy5cbiAgICogQHByaXZhdGVcbiAgICogQHNlZSBzY3JvbGxUb1xuICAgKi9cbiAgc2Nyb2xsVHJhbnNpdGlvblRvU2xpZGVfKGlzTW92aW5nRm9yd2FyZCwgbmV4dFNsaWRlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuZWwuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcblxuICAgIGlmICghaXNNb3ZpbmdGb3J3YXJkKSB7XG4gICAgICBuZXh0U2xpZGUubW92ZUJlZm9yZUZpcnN0KCk7XG4gICAgICBuZXh0U2xpZGUuc2hvdygpO1xuICAgICAgc2Nyb2xsVG8odGhpcy5jdXJyZW50U2xpZGVfLmVsLm9mZnNldFRvcCwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRTbGlkZS5zaG93KCk7XG4gICAgfVxuXG4gICAgc2Nyb2xsVG8obmV4dFNsaWRlLmVsLm9mZnNldFRvcCwgNTAwLCAoKSA9PiB7XG4gICAgICB0aGlzLmN1cnJlbnRTbGlkZV8uaGlkZSgpO1xuXG4gICAgICBpZiAoaXNNb3ZpbmdGb3J3YXJkKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFNsaWRlXy5tb3ZlQWZ0ZXJMYXN0KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWwuc3R5bGUub3ZlcmZsb3cgPSAnYXV0byc7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBuZXh0U2xpZGUpO1xuICAgICAgfSwgMTUwKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2l0aW9ucyB0byBhIHNsaWRlLCB3aXRob3V0IGRvaW5nIHRoZSBzY3JvbGwgYW5pbWF0aW9uLiBJZiB0aGUgcGFnZSBpc1xuICAgKiBhbHJlYWR5IGluaXRpYWxpc2VkIGFuZCBvbiBtb2JpbGUgZGV2aWNlLCBpdCB3aWxsIGRvIGEgc2xpZGUgYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTW92aW5nRm9yd2FyZCBXaGV0aGVyIHdlJ3JlIGdvaW5nIGZvcndhcmQgb3IgYmFja3dhcmRzLlxuICAgKiBAcGFyYW0ge1NsaWRlfSBuZXh0U2xpZGUgTmV4dCBzbGlkZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gYmUgY2FsbGVkIHVwb24gZmluaXNoaW5nLiBUaGlzIGlzIGFcbiAgICogc3luYyBmdW5jdGlvbiBzbyBpdCdsbCBoYXBwZW4gb24gcnVuIHRpbWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0cmFuc2l0aW9uVG9TbGlkZV8oaXNNb3ZpbmdGb3J3YXJkLCBuZXh0U2xpZGUsIGNhbGxiYWNrKSB7XG4gICAgc2Nyb2xsVG8oMCwgMCk7XG4gICAgbGV0IGNsYXNzTmFtZSA9ICdzbGlkZUluUmlnaHQnO1xuXG4gICAgaWYgKCFpc01vdmluZ0ZvcndhcmQpIHtcbiAgICAgIG5leHRTbGlkZS5tb3ZlQmVmb3JlRmlyc3QoKTtcbiAgICAgIGNsYXNzTmFtZSA9ICdzbGlkZUluTGVmdCc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY3VycmVudFNsaWRlXykge1xuICAgICAgaWYgKGlzTW92aW5nRm9yd2FyZCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRTbGlkZV8ubW92ZUFmdGVyTGFzdCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN1cnJlbnRTbGlkZV8uaGlkZSgpO1xuICAgIH1cblxuICAgIG5leHRTbGlkZS5zaG93KCk7XG5cbiAgICBpZiAodGhpcy5pbml0aWFsaXNlZCAmJlxuICAgICAgICB0aGlzLnBsdWdpbnMudG91Y2ggJiZcbiAgICAgICAgdGhpcy5wbHVnaW5zLnRvdWNoLmlzRW5hYmxlZCkge1xuICAgICAgRE9NLm9uY2UobmV4dFNsaWRlLmVsLCBET00uZ2V0QW5pbWF0aW9uRXZlbnQoKSwgKCkgPT4ge1xuICAgICAgICBuZXh0U2xpZGUuZWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIG5leHRTbGlkZSk7XG4gICAgICB9KTtcblxuICAgICAgbmV4dFNsaWRlLmVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBuZXh0U2xpZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuZXZlciBhIHNsaWRlIGlzIGNoYW5nZWQsIHRoaXMgZnVuY3Rpb24gZ2V0cyBjYWxsZWQuIEl0IHVwZGF0ZXMgdGhlXG4gICAqIHJlZmVyZW5jZXMgdG8gdGhlIGN1cnJlbnQgc2xpZGUsIGRpc2FibGVzIHRoZSBtb3ZpbmcgZmxhZyBhbmQgZmlyZXNcbiAgICogYSBjdXN0b20gZXZlbnQuXG4gICAqIEBwYXJhbSB7U2xpZGV9IHNsaWRlIFRoZSBzbGlkZSB3ZSdyZSB0cmFuc2l0aW9uaW5nIHRvLlxuICAgKiBAZmlyZXMgV2ViU2xpZGUjd3M6c2xpZGUtY2hhbmdlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvblNsaWRlQ2hhbmdlXyhzbGlkZSkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRTbGlkZV8pIHtcbiAgICAgIHRoaXMuY3VycmVudFNsaWRlXy5kaXNhYmxlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50U2xpZGVfID0gc2xpZGU7XG4gICAgdGhpcy5jdXJyZW50U2xpZGVJXyA9IHNsaWRlLmk7XG4gICAgdGhpcy5jdXJyZW50U2xpZGVfLmVuYWJsZSgpO1xuICAgIHRoaXMuaXNNb3ZpbmcgPSBmYWxzZTtcblxuICAgIERPTS5maXJlRXZlbnQodGhpcy5lbCwgJ3dzOnNsaWRlLWNoYW5nZScsIHtcbiAgICAgIHNsaWRlczogdGhpcy5tYXhTbGlkZV8sXG4gICAgICBjdXJyZW50U2xpZGUwOiB0aGlzLmN1cnJlbnRTbGlkZUlfLFxuICAgICAgY3VycmVudFNsaWRlOiB0aGlzLmN1cnJlbnRTbGlkZUlfICsgMVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdvZXMgdG8gdGhlIG5leHQgc2xpZGUuXG4gICAqL1xuICBnb05leHQoKSB7XG4gICAgbGV0IG5leHRJbmRleCA9IHRoaXMuY3VycmVudFNsaWRlSV8gKyAxO1xuXG4gICAgaWYgKG5leHRJbmRleCA+PSB0aGlzLm1heFNsaWRlXykge1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubG9vcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5leHRJbmRleCA9IDA7XG4gICAgfVxuXG4gICAgdGhpcy5nb1RvU2xpZGUobmV4dEluZGV4LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHb2VzIHRvIHRoZSBwcmV2aW91cyBzbGlkZS5cbiAgICovXG4gIGdvUHJldigpIHtcbiAgICBsZXQgcHJldkluZGV4ID0gdGhpcy5jdXJyZW50U2xpZGVJXyAtIDE7XG5cbiAgICBpZiAocHJldkluZGV4IDwgMCkge1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubG9vcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHByZXZJbmRleCA9IHRoaXMubWF4U2xpZGVfIC0gMTtcbiAgICB9XG5cbiAgICB0aGlzLmdvVG9TbGlkZShwcmV2SW5kZXgsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gbnVtYmVyIGlzIGEgdmFsaWQgaW5kZXggdG8gZ28gdG8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbmRleCB0byBjaGVjay5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB5b3UgY2FuIG1vdmUgdG8gdGhhdCBzbGlkZSBvciBub3QuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc1ZhbGlkSW5kZXhTbGlkZV8oaSkge1xuICAgIHJldHVybiB0eXBlb2YgaSA9PT0gJ251bWJlcicgJiYgaSA+PSAwICYmIGkgPCB0aGlzLm1heFNsaWRlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0IHRoZSBzaG93biBzbGlkZSBvbiBsb2FkLiBJdCdsbCBmZXRjaCBpdCBmcm9tIHRoZSBIYXNoIGlmIHByZXNlbnRcbiAgICogYW5kLCBvdGhlcndpc2UsIGl0J2xsIGRlZmF1bHQgdG8gdGhlIGZpcnN0IG9uZS5cbiAgICogQHByaXZhdGVcbiAgICogQHNlZSBIYXNoLmdldFNsaWRlTnVtYmVyXG4gICAqL1xuICBpbml0U2xpZGVzXygpIHtcbiAgICBsZXQgc2xpZGVOdW1iZXIgPSB0aGlzLnBsdWdpbnMuaGFzaC5jb25zdHJ1Y3Rvci5nZXRTbGlkZU51bWJlcigpO1xuXG4gICAgLy8gTm90IHZhbGlkXG4gICAgaWYgKHNsaWRlTnVtYmVyID09PSBudWxsIHx8XG4gICAgICAgIHNsaWRlTnVtYmVyID49IHRoaXMubWF4U2xpZGVfKSB7XG4gICAgICBzbGlkZU51bWJlciA9IDA7XG4gICAgfVxuXG4gICAgLy8gS2VlcGluZyB0aGUgb3JkZXJcbiAgICBpZiAoc2xpZGVOdW1iZXIgIT09IDApIHtcbiAgICAgIGxldCBpID0gMDtcblxuICAgICAgd2hpbGUoaSA8IHNsaWRlTnVtYmVyKSB7XG4gICAgICAgIHRoaXMuc2xpZGVzW2ldLm1vdmVBZnRlckxhc3QoKTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZ29Ub1NsaWRlKHNsaWRlTnVtYmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHpvb21cbiAgICovXG4gIHRvZ2dsZVpvb20oKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaG93SW5kZXgpIHtcbiAgICAgIHRoaXMucGx1Z2lucy56b29tLnRvZ2dsZVpvb20oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzYWJsZXMgdGhlIHdlYnNsaWRlcyBlbGVtZW50IGFkZGluZyBhIGNsYXNzIFwiZGlzYWJsZWRcIlxuICAgKi9cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoQ0xBU1NFUy5ESVNBQkxFRCk7XG5cbiAgICBpZiAodGhpcy5wbHVnaW5zLmF1dG9zbGlkZSAmJlxuICAgICAgdGhpcy5wbHVnaW5zLmF1dG9zbGlkZS50aW1lICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5wbHVnaW5zLmF1dG9zbGlkZS5zdG9wKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZXMgdGhlIHdlYnNsaWRlcyBlbGVtZW50IHJlbW92aW5nIGEgY2xhc3MgXCJkaXNhYmxlZFwiXG4gICAqL1xuICBlbmFibGUoKSB7XG4gICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTRVMuRElTQUJMRUQpO1xuXG4gICAgaWYgKHRoaXMucGx1Z2lucy5hdXRvc2xpZGUgJiZcbiAgICAgIHRoaXMucGx1Z2lucy5hdXRvc2xpZGUudGltZSAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMucGx1Z2lucy5hdXRvc2xpZGUucGxheSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgaXQgaXMgZGlzYWJsZWRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWwuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTRVMuRElTQUJMRUQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1dHMgdGhlIGJyb3dzZXIgaW50byBmdWxsc2NyZWVuXG4gICAqL1xuICBmdWxsc2NyZWVuKCkge1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIGNvbnN0IGlzRnVsbHNjcmVlbiA9IGRvY3VtZW50LmZ1bGxzY3JlZW5cbiAgICAgIHx8IGRvY3VtZW50LndlYmtpdElzRnVsbFNjcmVlblxuICAgICAgfHwgZG9jdW1lbnQubW96RnVsbFNjcmVlblxuICAgICAgfHwgZG9jdW1lbnQubXNGdWxsU2NyZWVuRWxlbWVudDtcblxuICAgIGlmICghaXNGdWxsc2NyZWVuKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBoYXJkIHRvIHRlc3QgcHJlZml4ZXMgKi9cbiAgICAgIGNvbnN0IHJlcXVlc3RGdWxsc2NyZWVuID0gZWwucmVxdWVzdEZ1bGxzY3JlZW5cbiAgICAgICAgICB8fCBlbC53ZWJraXRSZXF1ZXN0RnVsbFNjcmVlblxuICAgICAgICAgIHx8IGVsLm1velJlcXVlc3RGdWxsU2NyZWVuXG4gICAgICAgICAgfHwgZWwubXNSZXF1ZXN0RnVsbHNjcmVlbjtcbiAgICAgIHJlcXVlc3RGdWxsc2NyZWVuLmNhbGwoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBoYXJkIHRvIHRlc3QgcHJlZml4ZXMgKi9cbiAgICAgIGNvbnN0IGNhbmNlbEZ1bGxzY3JlZW4gPSBkb2N1bWVudC5leGl0RnVsbFNjcmVlblxuICAgICAgICB8fCBkb2N1bWVudC53ZWJraXRDYW5jZWxGdWxsU2NyZWVuXG4gICAgICAgIHx8IGRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW5cbiAgICAgICAgfHwgZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbjtcblxuICAgICAgY2FuY2VsRnVsbHNjcmVlbi5jYWxsKGRvY3VtZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgcGx1Z2luIHRvIGJlIGxvYWRlZCB3aGVuIHRoZSBpbnN0YW5jZSBpcyBjcmVhdGVkLiBJdCBhbGxvd3NcbiAgICogKG9uIHB1cnBvc2UpIHRvIHJlcGxhY2UgZGVmYXVsdCBwbHVnaW5zLlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGtleSBUaGV5IGtleSB1bmRlciB3aGljaCBpdCdsbCBiZSBzdG9yZWQgaW5zaWRlIG9mIHRoZVxuICAgKiBpbnN0YW5jZSwgaW5zaWRlIHRoZSBwbHVnaW5zIGRpY3QuXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBjdG8gUGx1Z2luIGNvbnN0cnVjdG9yLlxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyUGx1Z2luKGtleSwgY3RvKSB7XG4gICAgUExVR0lOU1trZXldID0gY3RvO1xuICB9XG59XG4iLCJpbXBvcnQgV2ViU2xpZGVzIGZyb20gJ3dlYnNsaWRlcy9zcmMvanMvbW9kdWxlcy93ZWJzbGlkZXMnXG5pbXBvcnQgJy4vYXNzZXRzL3Njc3MvZnVsbC5zY3NzJ1xuaW1wb3J0ICcuL2Fzc2V0cy9zY3NzL2luZGV4LnNjc3MnXG5cblxuXG5leHBvcnQgZGVmYXVsdCBXZWJTbGlkZXNcbiIsIi8qKlxuICog6aG16Z2i55qEIG1haW4uanNcbiAqL1xuaW1wb3J0IFNsaWRlIGZyb20gJ25vZGVwcHQtanMnO1xuXG53aW5kb3cuV2ViU2xpZGUgPSBTbGlkZTtcblxuXG4iXSwibWFwcGluZ3MiOiI7OztBQUFBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFFQTs7QUM1Q0E7QUFFQTtBQUNBO0FBRUE7Ozs7QUFHQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQURBO0FBSUE7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZOQTs7QUNSQTtBQUVBOzs7O0FBR0E7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7Ozs7QUFLQTtBQUNBOzs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEVBOztBQ0xBO0FBU0E7Ozs7QUFHQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQTdCQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTtBQWlCQTs7QUNqQkE7QUFFQTtBQUlBOzs7O0FBR0E7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUVBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF6Q0E7O0FDVEE7QUFDQTtBQUVBOzs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQXBFQTs7QUNQQTtBQUNBO0FBRUE7Ozs7QUFHQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUE5QkE7QUFDQTtBQWdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBFQTs7QUNOQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUxBO0FBV0E7Ozs7QUFHQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUVBOzs7OztBQUlBO0FBQ0E7Ozs7O0FBSUE7QUFDQTs7Ozs7QUFJQTtBQUNBOzs7OztBQUlBO0FBQ0E7Ozs7O0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEzSEE7O0FDdkJBO0FBRUE7Ozs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFNQTtBQUNBO0FBN0RBOztBQ05BO0FBR0E7Ozs7QUFHQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqSEE7O0FDTkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTkE7QUFhQTs7OztBQUdBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFFQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7O0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUZBO0FBS0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBL01BOztBQ2xCQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7Ozs7QUFHQTtBQUNBOzs7OztBQUtBO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7O0FBSUE7QUFDQTs7OztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBbElBO0FBQ0E7OztBQ2xCQTtBQUNBO0FBRUE7Ozs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFqREE7O0FDUEE7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBSUE7QUFDQTs7O0FBR0E7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7O0FBSUE7QUFDQTs7Ozs7QUFJQTtBQUNBOzs7OztBQUlBO0FBQ0E7Ozs7O0FBSUE7QUFFQTs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFIQTtBQVFBOzs7OztBQUlBO0FBQ0E7Ozs7O0FBSUE7QUFFQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqS0E7QUFtS0E7Ozs7O0FBR0E7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBWkE7QUFjQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBL0ZBOztBQzlLQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUNUQTtBQUVBO0FBRUE7Ozs7Ozs7OztBQVFBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFVQTtBQUVBOzs7O0FBR0E7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUVBOzs7OztBQUlBO0FBRUE7Ozs7O0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQS9LQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFlQTs7OztBQUdBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7Ozs7O0FBSUE7QUFDQTs7Ozs7O0FBS0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTs7Ozs7QUFJQTtBQUNBOzs7OztBQUlBO0FBQ0E7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTs7Ozs7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQTNiQTs7Ozs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBSUE7O0FDTkE7OztBQUdBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n")}]);